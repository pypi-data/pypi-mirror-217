from __future__ import annotations

import enum

from abc import ABCMeta, abstractmethod
from typing import Any, List, Optional, TypeVar, Union
from uuid import uuid4

from typeguard import check_type

import jijmodeling.expression.serializable as _serializable

NumericValue = Union[int, float]

TExpression = TypeVar("TExpression", bound="Expression")


class Expression(metaclass=_serializable.Serializable):
    """
    Mathematical expression of JijModeling.

    The Expression class provides each method that defines operator rules.
    """

    _paren_parents = ()

    def __init__(self, uuid: Optional[str] = None):
        self._latex_repr: Optional[str] = None
        self._uuid: str = uuid if uuid is not None else uuid4().hex

    @property
    def uuid(self) -> str:
        """
        Unique id which is str type since UUID object is not serializable.

        default value is generated by `uuid.uuid4().hex`.

        Returns:
            str: _description_
        """
        return self._uuid

    @abstractmethod
    def is_operatable(self) -> bool:
        """
        Specify whether the operators (+, -, *, /,...) can be applied to the.

        expression. For example, "a[3]" is true, whereas "a" is not.

        Returns:
            bool: defaults False.
        """
        return False

    def _needs_parens(self, parent) -> bool:
        """Whether this expression needs parentheses surrounding it, given that it is a child of `parent`.

        The default implementation always returns False. Subclasses override this method to indicate
        when they need parentheses to help disambiguate with the parent expression.
        """
        return False

    def _make_latex(self) -> str:
        """
        Outputs a latex representation.

        If `self._latex_repr` is not None, it
        will take precedence. If you want to get the latex representation of
        child objects in `_default_repr_latex_` of each class, use the method.

        Returns:
            str: latex representation.
        """
        if self._latex_repr is not None:
            return self._latex_repr
        else:
            from jijmodeling.latex_repr.latex_repr import expr_latex_repr

            return expr_latex_repr(self)

    def _repr_latex_(self) -> str:
        """
        Latex representation for Jupyter notebook.

        Returns:
            str: latex string
        """
        return f"${self._make_latex()}$"

    def set_latex(self: TExpression, latex_repr: str) -> TExpression:
        """
        Change LaTeX Representation.

        Returns:
            Expression: `self`

        Examples:
            ```python
            import jijmodeling as jm
            d = jm.Placeholder("d")
            n = d.shape[0]
            n._repr_latex_()
            # $|d|_0$
            n = d.shape[0].set_latex("n")
            n._repr_latex()
            # $n$
            ```
        """
        self._latex_repr = latex_repr
        return self

    def __add__(self, other):
        return Add.create(self, other)

    def __radd__(self, other):
        return Add.create(self, other)

    def __ladd__(self, other):
        return self.__add__(other)

    def __sub__(self, other):
        return Add.create(self, -1 * other)

    def __rsub__(self, other):
        return Add.create(other, -1 * self)

    def __lsub__(self, other):
        return Add.create(self, -1 * other)

    def __neg__(self):
        return -1 * self

    def __mul__(self, other):
        return Mul.create(self, other)

    def __rmul__(self, other):
        return self.__mul__(other)

    def __lmul__(self, other):
        return self.__mul__(other)

    def __truediv__(self, other):
        return Div.create(self, other)

    def __rtruediv__(self, other):
        return Div.create(other, self)

    def __pow__(self, other):
        return Power.create(self, other)

    def __rpow__(self, other):
        return Power.create(other, self)

    def __mod__(self, other):
        return Mod.create(self, other)

    def __eq__(self, other):
        import jijmodeling.expression.condition as _condition

        return _condition.Equal(self, other)

    def __ne__(self, other):
        import jijmodeling.expression.condition as _condition

        return _condition.NotEqual(self, other)

    def __lt__(self, other):
        import jijmodeling.expression.condition as _condition

        return _condition.LessThan(self, other)

    def __le__(self, other):
        import jijmodeling.expression.condition as _condition

        return _condition.LessThanEqual(self, other)

    def __gt__(self, other):
        import jijmodeling.expression.condition as _condition

        return _condition.LessThan(other, self)

    def __ge__(self, other):
        import jijmodeling.expression.condition as _condition

        return _condition.LessThanEqual(other, self)

    def __bool__(self):
        raise TypeError(
            "Cannot convert jm.Expression to bool to avoid unexpected bahavior. Consider us `jm.expr_same` instead in order to compare `jm.Expression` objects."
        )

    @abstractmethod
    def children(self) -> List[Expression]:
        """
        This method used at `jijmodeling.expression.extract`.

        Returns:
            List[Expression]: children of the expression.
        """
        return []


class DataType(enum.Enum):
    INT = "INT"
    FLOAT = "FLOAT"


class Number(Expression):
    """Number class."""

    def __init__(
        self,
        value: Union[NumericValue, Number],
        dtype: Optional[Union[str, DataType]] = None,
        uuid: Optional[str] = None,
    ):
        super().__init__(uuid=uuid)
        if isinstance(value, Number):
            value = value.value
        self._value: NumericValue = value

        self._dtype: DataType
        if dtype is None:
            self._dtype = (
                DataType("INT") if isinstance(value, int) else DataType("FLOAT")
            )
        elif isinstance(dtype, str):
            self._dtype = DataType(dtype.upper())
        elif isinstance(dtype, DataType):
            self._dtype = dtype
        else:
            raise TypeError(f"dtype is str or DataType, not {type(dtype)}.")

        if self._dtype == DataType.FLOAT:
            self._value = float(value)
        elif self._dtype == DataType.INT:
            self._value = int(value)

    def _default_repr_latex_(self) -> str:
        return str(self.value)

    @property
    def value(self) -> NumericValue:
        """Number's value."""
        return self._value

    @property
    def dtype(self) -> DataType:
        """Value type "INT" or "FLOAT"."""
        return self._dtype

    def is_operatable(self) -> bool:
        return True

    def __int__(self):
        return int(self.value)

    def __float__(self):
        return float(self.value)

    def __repr__(self) -> str:
        return str(self.value)

    def _make_latex(self) -> str:
        return str(self.value)

    def children(self) -> List[Expression]:
        return []


def _numeric_to_expression(expr: Union[Expression, NumericValue]) -> Expression:
    if isinstance(expr, Expression):
        return expr
    else:
        return Number(expr)


class BinaryOperator(Expression, metaclass=ABCMeta):
    _mark = ""

    def __init__(
        self,
        left: Expression,
        right: Expression,
        uuid: Optional[str] = None,
    ):
        """
        BinaryOperator Constructor.

        Args:
            left (Expression): left hand side
            right (Expression): right hand side
        """
        super().__init__(uuid=uuid)

        self._left = left
        self._right = right

        # make sure there is only `Expression`s.
        check_type(self._left, Expression)
        check_type(self._right, Expression)

        import jijmodeling.utils.utils as _uutils

        _error_msg = "{0} is not operatable. If {0} should be operatable, please check the subscripts and dim of {0}."
        _uutils.validate_value(
            "left.is_operatable()",
            self._left.is_operatable(),
            _error_msg.format(self._left),
        )
        _uutils.validate_value(
            "right.is_operatable()",
            self._right.is_operatable(),
            _error_msg.format(self._right),
        )

    @property
    def left(self) -> Expression:
        return self._left

    @property
    def right(self) -> Expression:
        return self._right

    def is_operatable(self):
        return True

    @classmethod
    @abstractmethod
    def operation(cls, left, right) -> Any:
        """
        Execute operation.

        Args:
            left (Any): left hand side operand
            right (Any): right hand side operand

        Example:
            ```python
            >>> Add.operation(1, 2)
            3
            >>> Mul.operation(-1, 4)
            -4
            >>> Div.operation(1, 2)
            0.5
            >>> Power.operation(2, 3)
            8
            >>> Mod.operation(10, 3)
            1
            ```
        """

    @classmethod
    def create(
        cls,
        left: Union[Expression, NumericValue],
        right: Union[Expression, NumericValue],
    ) -> Expression:
        """
        In BinaryOperator, there are some opeartions that can be simplified.

        during construction, such as 3+0=3.

        Therefore, it is recommended to call `.create` method to create
        the object instead of calling `__init__.` In the `create` metho,
        the operand is checked before calling the constructor.
        """
        _left = _numeric_to_expression(left)
        _right = _numeric_to_expression(right)
        if isinstance(_left, Number) and isinstance(_right, Number):
            return Number(cls.operation(_left.value, _right.value))
        return cls(_left, _right)

    def __repr__(self) -> str:
        def to_str(e):
            if e._needs_parens(self):
                return f"({e})"
            else:
                return f"{e}"

        left = to_str(self.left)
        right = to_str(self.right)
        return left + self._mark + right

    def children(self) -> List[Expression]:
        return [self.left, self.right]


class Add(BinaryOperator):
    """Represents Add operator."""

    _mark = "+"

    @classmethod
    def create(
        cls,
        left: Union[Expression, NumericValue],
        right: Union[Expression, NumericValue],
    ) -> Expression:
        """
        Constructor for Add object.

        Args:
            left (Union[Expression, NumericValue]): left hand side
            right (Union[Expression, NumericValue]): right hand side

        Returns:
            Expression: left + right

        Example:
            ```python
            >>> import jijmodeling as jm
            >>> d, a = jm.Placeholder("d"), jm.Placeholder("a")
            >>> Add.create(d, a)
            d + a
            >>> Add.create(d, 0)
            d
            >>> type(Add.create(3, 2))
            <class 'jijmodeling.expression.expression.Number'>
            ```
        """
        _left: Expression = _numeric_to_expression(left)
        _right: Expression = _numeric_to_expression(right)
        if isinstance(_left, Number) and _left.value == 0.0:
            return _right
        if isinstance(_right, Number) and _right.value == 0.0:
            return _left
        if isinstance(_left, Number) and isinstance(_right, Number):
            return Number(_left.value + _right.value)
        return cls(_left, _right)

    @classmethod
    def operation(cls, left, right):
        return left + right

    def _needs_parens(self, parent) -> bool:
        needs = (Mul, Div, Power, Mod)
        return isinstance(parent, needs)

    def __repr__(self) -> str:
        if self.left._needs_parens(self):
            left = f"({self.left})"
        else:
            left = str(self.left)

        # right side needs addition consideration depending
        # on whether it's negative or positive
        right = str(self.right)
        # special-casing "-1*"
        if right.startswith("-1*"):
            mark = " - "
            right = right[3:]
        elif right[0] == "-":
            mark = " - "
            right = right[1:]
        else:
            mark = self._mark

        if self.right._needs_parens(self):
            right = f"({right})"
        return left + mark + right


class Mul(BinaryOperator):
    _mark = r"*"

    @classmethod
    def create(
        cls,
        left: Union[Expression, NumericValue],
        right: Union[Expression, NumericValue],
    ) -> Expression:
        """
        Constructor for Mul object.

        Args:
            left (Union[Expression, NumericValue]): left hand side
            right (Union[Expression, NumericValue]): right hand side

        Returns:
            Expression: left * right

        Example:
            ```python
            >>> import jijmodeling as jm
            >>> d, a = jm.Placeholder("d"), jm.Placeholder("a")
            >>> Mul.create(d, a)
            d * a
            >>> Mul.create(d, 1)
            d
            >>> Mul.create(d, 0)
            0.0
            >>> type(Mul.create(3, 2))
            <class 'jijmodeling.expression.expression.Number'>
            ```
        """
        _left: Expression = _numeric_to_expression(left)
        _right: Expression = _numeric_to_expression(right)
        # case: both hand sides are numbers
        if isinstance(_left, Number) and isinstance(_right, Number):
            return Number(_left.value * _right.value)
        elif isinstance(_left, Number):
            # case: left hand side is a number
            # case: identity element
            if _left.value == 1.0:
                return _right
            # case: zero element
            if _left.value == 0.0:
                return Number(0.0)
        elif isinstance(_right, Number):
            # case: right hand side is a number
            # case: identity element
            if _right.value == 1.0:
                return _left
            # case: zero element
            if _right.value == 0.0:
                return Number(0.0)
            # put coefficient in front of variable terms
            else:
                return cls(_right, _left)
        return cls(_left, _right)

    def _needs_parens(self, parent) -> bool:
        needs = (Div, Power, Mod)
        return isinstance(parent, needs)

    @classmethod
    def operation(cls, left, right):
        return left * right


class Div(BinaryOperator):
    _mark = "/"

    def __init__(self, left: Expression, right: Expression, uuid: Optional[str] = None):
        # The .create method simplified operations (ex. 0 + d = d),
        # but does not handle errors for impossible operations such as division by zero.
        # Impossible operation errors must be raised in __init__ constructor
        # because they must raise in any path constration.
        if isinstance(right, Number) and right.value == 0.0:
            raise ZeroDivisionError()

        import jijmodeling.expression.utils as _utils

        _utils.check_non_decision_variable(
            [right],
            f"The denominotor cannot contain a decision variable in `{left}/{right} <-`.",
        )

        super().__init__(left, right, uuid=uuid)

    @classmethod
    def create(
        cls,
        left: Union[Expression, NumericValue],
        right: Union[Expression, NumericValue],
    ) -> Expression:
        """
        Constructor for Div object.

        Args:
            left (Union[Expression, NumericValue]): left hand side
            right (Union[Expression, NumericValue]): right hand side

        Returns:
            Expression: left // right

        Raises:
            ModelingError: The denominator cannot contain a decision variable.

        Example:
            ```python
            >>> import jijmodeling as jm
            >>> d, a = jm.Placeholder("d"), jm.Placeholder("a")
            >>> Div.create(d, a)
            d // a
            >>> Div.create(d, 1)
            d
            >>> x = jm.Binary("x")
            >>> Div.create(d, x)
            jijmodeling.exceptions.ModelingError: The denominator cannot contain a decision variable.
            >>> type(Div.create(3, 2))
            <class 'jijmodeling.expression.expression.Number'>
            ```
        """
        _left = _numeric_to_expression(left)
        _right = _numeric_to_expression(right)

        if isinstance(_right, Number) and (not isinstance(_left, Number)):
            if _right.value == 1.0:
                return _left
        elif isinstance(_left, Number) and (not isinstance(_right, Number)):
            if _left.value == 0.0:
                return _left  # 0 / d = 0
        elif isinstance(_left, Number) and isinstance(_right, Number):
            return Number(_left.value / _right.value)
        return cls(_left, _right)

    def _needs_parens(self, parent) -> bool:
        needs = (Add, Mul, Div, Power)
        return isinstance(parent, needs)

    @classmethod
    def operation(cls, left, right):
        return left / right


class Power(BinaryOperator):
    _mark = "^"

    def __init__(self, left: Expression, right: Expression, uuid: Optional[str] = None):
        import jijmodeling.expression.utils as _utils

        _utils.check_non_decision_variable(
            [right],
            f"The denominotor cannot contain a decision variable in `{left}/{right} <-`.",
        )
        super().__init__(left, right, uuid)

    @classmethod
    def create(
        cls,
        left: Union[Expression, NumericValue],
        right: Union[Expression, NumericValue],
    ) -> Expression:
        """
        Constructor for Power object.

        Args:
            left (Union[Expression, NumericValue]): left hand side
            right (Union[Expression, NumericValue]): right hand side

        Returns:
            Expression: left ** right

        Raises:
            ModelingError: The exponent cannot contain a decision variable.
            ModelingError: If there is a decision variable in left,
                           the exponent cannot be specified other than Number.
                           This condition may be relaxed in a version update.

        Example:
            ```python
            >>> import jijmodeling as jm
            >>> d, a = jm.Placeholder("d"), jm.Placeholder("a")
            >>> Power.create(d, a)
            d ^ a
            >>> Power.create(d, 1)
            d
            >>> x = jm.Binary("x")
            >>> Power.create(d, x)
            jijmodeling.exceptions.ModelingError: The exponent cannot contain a decision variable.
            >>> Power.create(x, d)
            jijmodeling.exceptions.ModelingError: If there is a decision variable in left,
                                                  the exponent cannot be specified other than Number.
                                                  This condition may be relaxed in a version update.
            >>> type(Power.create(3, 2))
            <class 'jijmodeling.expression.expression.Number'>
            ```
        """
        # obj: Power = cls(left, right tils import extract_nodes

        _left = _numeric_to_expression(left)
        _right = _numeric_to_expression(right)

        # The placeholder is now supported in the exponent part, but it must
        # contain an integer.
        if isinstance(_right, Number):
            if _right.value == 1.0:
                return _left
            elif _right.value == 0.0:
                return Number(1)
        if isinstance(_left, Number):
            if _left.value == 1.0:
                return Number(1)
            elif _left.value == 0.0:
                return Number(0)
        if isinstance(_left, Number) and isinstance(_right, Number):
            return Number(_left.value**_right.value)
        return cls(_left, _right)

    @classmethod
    def operation(cls, left, right):
        return left**right

    def _needs_parens(self, parent):
        needs = (Div, Power)
        return isinstance(parent, needs)


class Mod(BinaryOperator):
    _mark = r"\mod"

    def __init__(self, left: Expression, right: Expression, uuid: Optional[str] = None):
        import jijmodeling.expression.utils as _utils

        _utils.check_non_decision_variable(
            [left, right],
            f"The left hand side and the right hand side cannot contain a decision variable in `{left}%{right} <-`.",
        )

        super().__init__(left, right, uuid)

    @classmethod
    def create(
        cls,
        left: Union[Expression, NumericValue],
        right: Union[Expression, NumericValue],
    ) -> Expression:
        """
        Constructor for Mod object.

        Args:
            left (Union[Expression, NumericValue]): left hand side
            right (Union[Expression, NumericValue]): right hand side

        Returns:
            Expression: left % right

        Raises:
            ModelingError: The left and the right cannot contain a decision variable.

        Example:
            ```python
            >>> import jijmodeling as jm
            >>> d, a = jm.Placeholder("d"), jm.Placeholder("a")
            >>> Mod.create(d, a)
            d ^ a
            >>> Mod.create(d, 1)
            d
            >>> x = jm.Binary("x")
            >>> Mod.create(d, x)
            jijmodeling.exceptions.ModelingError: The left and the right cannot contain a decision variable.
            >>> Mod.create(x, d)
            jijmodeling.exceptions.ModelingError: The left and the right cannot contain a decision variable.
            >>> type(Mod.create(3, 2))
            <class 'jijmodeling.expression.expression.Number'>
            ```
        """
        _left = _numeric_to_expression(left)
        _right = _numeric_to_expression(right)

        if isinstance(_right, Number) and _right.value == 1.0:
            return _left
        if isinstance(_left, Number) and isinstance(_right, Number):
            return Number(_left.value % _right.value)
        return cls(_left, _right)

    @classmethod
    def operation(cls, left, right):
        return left % right

    def _needs_parens(self, parent) -> bool:
        needs = (Mul, Div, Power, Mod)
        return isinstance(parent, needs)

    def __repr__(self) -> str:
        # same as `BinaryOperator`'s implementation
        # but using " mod " instead of `self._mark`
        def to_str(e):
            if e._needs_parens(self):
                return f"({e})"
            else:
                return f"{e}"

        left = to_str(self.left)
        right = to_str(self.right)
        return left + " mod " + right
