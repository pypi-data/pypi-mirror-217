import{Controller}from"../base.mjs";import{TableView}from"../../view/table.mjs";import{View}from"../../view/base.mjs";import{FormView}from"../../view/forms/base.mjs";import{SearchListInputView,StringInputView,SearchListInputListView}from"../../view/forms/input.mjs";import{MultiLoraInputView,MultiInversionInputView}from"./model-manager.mjs";import{isEmpty,waitFor,createElementsFromString}from"../../base/helpers.mjs";import{ElementBuilder}from"../../base/builder.mjs";const E=new ElementBuilder;class ModelPickerListInputView extends SearchListInputListView{static classList=SearchListInputListView.classList.concat(["model-picker-list-input-view"])}class ModelPickerStringInputView extends StringInputView{setValue(t,e){return isEmpty(t)||(t=t.startsWith("<")?createElementsFromString(t)[0].innerText:t.split("/")[1]),super.setValue(t,e)}}class ModelPickerInputView extends SearchListInputView{static placeholder="Start typing to search modelsâ€¦";static stringInputClass=ModelPickerStringInputView;static listInputClass=ModelPickerListInputView}class AdditionalWeightsFormView extends FormView{static className="additional-weights-form-view";static autoSubmit=!0;static collapseFieldSets=!0;static fieldSets={"Additional Weights":{lora:{class:MultiLoraInputView,label:"LoRA",config:{tooltip:"LoRA stands for <strong>Low Rank Adapation</strong>, it is a kind of fine-tuning that can perform very specific modifications to Stable Diffusion such as training an individual's appearance, new products that are not in Stable Diffusion's training set, etc."}},inversion:{class:MultiInversionInputView,label:"Textual Inversion",config:{tooltip:"Textual Inversion is another kind of fine-tuning that teaches novel concepts to Stable Diffusion in a small number of images, which can be used to positively or negatively affect the impact of various prompts."}}}}}class ModelTensorRTTableView extends TableView{constructor(t,e,i){super(t,e),this.buildEngine=i}static canSort=!1;static columnFormatters={Build:function(t,e){if(!0===t)return E.span().content("Ready");{let i=E.button().content("Build").on("click",(async()=>{try{i.disabled(!0).addClass("loading-bar loading"),await this.buildEngine(e),i.removeClass("loading-bar").removeClass("loading").content("Ready")}catch(t){i.removeClass("loading-bar loading").disabled(!1)}}));return"building"===t&&i.disabled(!0).addClass("loading-bar loading"),i}}}}class ModelTensorRTStatusView extends View{static tagName="enfugue-tensorrt-status-view";static supportedNetworks={unet:"UNet",controlled_unet:"Controlled UNet",inpaint_unet:"Inpainting UNet"};static tensorRTDescription=["TensorRT is a technology created by Nvidia that transforms an AI model into one that takes advantage of hardware acceleration available on Nvidia GPUs.","As there are numerous varying architectures used by Nvidia that support this technology, these engines must be compiled by an architecture compatible with your actual hardware, rather than distributed by AI model providers.","The compilation time for each model varies, but generally takes between 15 and 30 minutes each. You can expect between 50% and 100% faster inference speeds during the engine's respective step(s).","The compiled engine is only useable for a model with the same checkpoint, LoRA, Textual Inversion and engine size. If you change any of those details about this model, it will require recompilation. You can safely change model prompts as desired without requiring a new engine."];static networkDescriptions={unet:"The network used when creating images with a prompt or base image.",controlled_unet:"The network used when creating images with a control image.",inpaint_unet:"The network used when inpainting or outpainting."};constructor(t,e,i){super(t),this.status=e,this.buildEngine=i}get tableData(){return Object.getOwnPropertyNames(this.constructor.supportedNetworks).map((t=>({"Network Name":this.constructor.supportedNetworks[t],Description:this.constructor.networkDescriptions[t],Build:this.status.building===t?"building":this.status[`${t}_ready`]})))}getNameFromLabel(t){for(let e in this.constructor.supportedNetworks)if(this.constructor.supportedNetworks[e]===t)return e;throw`Unknown network ${t}`}async build(){let t=await super.build(),e=new ModelTensorRTTableView(this.config,this.tableData,(t=>this.buildEngine(this.getNameFromLabel(t["Network Name"]))));for(let e of this.constructor.tensorRTDescription)t.append(E.p().class("margin").content(e));return t.append(await e.getNode())}}class ModelPickerFormView extends FormView{static className="model-picker";static autoSubmit=!0;static fieldSets={Model:{model:{class:ModelPickerInputView}}};static tensorRTLogo="/static/img/brand/tensorrt.png";setTensorRTStatus(t,e){let i=this.node.find("#tensorrt");if(t.supported){let s=ModelTensorRTStatusView.supportedNetworks,n=Object.getOwnPropertyNames(s),o=n.length,a=n.reduce(((e,i)=>(e[i]=t[`${i}_ready`],e)),{}),r=Object.values(a).filter((t=>t)).length;isEmpty(i)?(i=E.div().id("tensorrt").append(E.img().src(this.constructor.tensorRTLogo),E.span().class("fraction").content(E.span().content(`${r}`),E.span().content(`${o}`))).on("click",(()=>e())),this.node.append(i)):i.off("click").on("click",(()=>e())).find("span.fraction").content(E.span().content(`${r}`),E.span().content(`${o}`)),t.ready?i.addClass("ready").data("tooltip","TensorRT is <strong>ready</strong>"):i.removeClass("ready").data("tooltip","TensorRT is <strong>not ready</strong>")}else isEmpty(i)||this.node.remove(i)}}class ModelPickerController extends Controller{static tensorRTStatusWindowWidth=500;static tensorRTStatusWindowHeight=750;getState(){return{model:this.formView.values,weights:this.additionalWeightsFormView.values}}getDefaultState(){return{model:null,weights:null}}setState(t){isEmpty(t.model)||this.formView.setValues(t.model).then((()=>this.formView.submit())),isEmpty(t.weights)||this.additionalWeightsFormView.setValues(t.weights).then((()=>this.additionalWeightsFormView.submit()))}async buildEngine(t,e){await this.model.post(`/models/${t}/tensorrt/${e}`),this.notify("info","Build Started","The engine will be busy throughout this TensorRT build. You will see a notification when it is complete, and the status indicator in the top bar will show ready or idle."),await waitFor((()=>!isEmpty(this.builtEngines[t])&&-1!==this.builtEngines[t].indexOf(e)),{interval:5e3})}async showBuildTensorRT(t){let e=await t.getTensorRTStatus(),i=await this.getCurrentEngineBuildProcess();isEmpty(i)||i.metadata.tensorrt_build.model!==t.name||(e.building=i.metadata.tensorrt_build.network);let s=new ModelTensorRTStatusView(this.config,e,(e=>this.buildEngine(t.name,e)));return await this.spawnWindow(`${t.name} TensorRT Status`,s,this.constructor.tensorRTStatusWindowWidth,this.constructor.tensorRTStatusWindowHeight)}async getCurrentEngineBuildProcess(){let t=await this.model.get("/invocation");for(let e of t)if(void 0!==e.metadata&&void 0!==e.metadata.tensorrt_build&&-1!==["queued","processing"].indexOf(e.status))return e;return null}async initialize(){this.builtEngines={},ModelPickerInputView.defaultOptions=async()=>(await this.model.get("/model-options")).reduce(((t,e)=>{let i="checkpoint"===e.type?"Checkpoint":"Preconfigured Model";return t[`${e.type}/${e.name}`]=`<strong>${e.name}</strong><em>${i}</em>`,t}),{}),this.formView=new ModelPickerFormView(this.config),this.additionalWeightsFormView=new AdditionalWeightsFormView(this.config),this.formView.onSubmit((async t=>{if(t.model){let[e,i]=t.model.split("/");if(this.engine.model=i,this.engine.modelType=e,"model"===e){this.additionalWeightsFormView.hide();try{let t=await this.model.DiffusionModel.query({name:i}),e=await t.getTensorRTStatus();this.publish("modelPickerChange",t),this.formView.setTensorRTStatus(e,(()=>this.showBuildTensorRT(t)))}catch(t){this.formView.setValues({model:null})}}else this.additionalWeightsFormView.show(),this.formView.setTensorRTStatus({supported:!1})}else this.formView.setTensorRTStatus({supported:!1})})),this.additionalWeightsFormView.onSubmit((async t=>{this.engine.lora=t.lora,this.engine.inversion=t.inversion})),this.application.container.appendChild(await this.formView.render()),this.application.container.appendChild(await this.additionalWeightsFormView.render()),this.subscribe("invocationError",(t=>{if(console.error(t),!isEmpty(t.metadata)&&!isEmpty(t.metadata.tensorrt_build)){let e=t.metadata.tensorrt_build.network,i=ModelTensorRTStatusView.supportedNetworks[e],s=t.metadata.tensorrt_build.model;this.notify("info","TensorRT Engine Build Failed",`${s} ${i} TensorRT Engine failed to build. Please try again.`)}})),this.subscribe("invocationComplete",(t=>{if(!isEmpty(t.metadata)&&!isEmpty(t.metadata.tensorrt_build)){let e=t.metadata.tensorrt_build.network,i=ModelTensorRTStatusView.supportedNetworks[e],s=t.metadata.tensorrt_build.model;this.notify("info","TensorRT Engine Build Complete",`Successfully built ${s} ${i} TensorRT Engine.`),isEmpty(this.builtEngines[s])&&(this.builtEngines[s]=[]),this.builtEngines[s].push(e)}}))}}export{ModelPickerController};
