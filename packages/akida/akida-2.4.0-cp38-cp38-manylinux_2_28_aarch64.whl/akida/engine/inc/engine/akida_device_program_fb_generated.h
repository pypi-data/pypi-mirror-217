// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AKIDADEVICEPROGRAMFB_AKIDA_FB_H_
#define FLATBUFFERS_GENERATED_AKIDADEVICEPROGRAMFB_AKIDA_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace akida {
namespace fb {

struct DeviceVersion;
struct DeviceVersionBuilder;

struct Np;
struct NpBuilder;

struct NpTrack;
struct NpTrackBuilder;

struct Fnp2FilterTrack;
struct Fnp2FilterTrackBuilder;

struct EpgTrack;
struct EpgTrackBuilder;

struct Record;
struct RecordBuilder;

struct Pass;
struct PassBuilder;

struct DmaConfigHeader;

struct LearningLayer;
struct LearningLayerBuilder;

struct Program;
struct ProgramBuilder;

enum IoType : int8_t {
  IoType_dense = 0,
  IoType_fnp_sparse = 1,
  IoType_cnp_sparse = 2,
  IoType_hrc_sparse = 3,
  IoType_MIN = IoType_dense,
  IoType_MAX = IoType_hrc_sparse
};

inline const IoType (&EnumValuesIoType())[4] {
  static const IoType values[] = {
    IoType_dense,
    IoType_fnp_sparse,
    IoType_cnp_sparse,
    IoType_hrc_sparse
  };
  return values;
}

inline const char * const *EnumNamesIoType() {
  static const char * const names[5] = {
    "dense",
    "fnp_sparse",
    "cnp_sparse",
    "hrc_sparse",
    nullptr
  };
  return names;
}

inline const char *EnumNameIoType(IoType e) {
  if (flatbuffers::IsOutRange(e, IoType_dense, IoType_hrc_sparse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIoType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DmaConfigHeader FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t w1_;
  uint32_t w2_;

 public:
  DmaConfigHeader()
      : w1_(0),
        w2_(0) {
  }
  DmaConfigHeader(uint32_t _w1, uint32_t _w2)
      : w1_(flatbuffers::EndianScalar(_w1)),
        w2_(flatbuffers::EndianScalar(_w2)) {
  }
  uint32_t w1() const {
    return flatbuffers::EndianScalar(w1_);
  }
  uint32_t w2() const {
    return flatbuffers::EndianScalar(w2_);
  }
};
FLATBUFFERS_STRUCT_END(DmaConfigHeader, 8);

struct DeviceVersion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceVersionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VENDOR_ID = 4,
    VT_PRODUCT_ID = 6,
    VT_MAJOR_REV = 8,
    VT_MINOR_REV = 10
  };
  uint8_t vendor_id() const {
    return GetField<uint8_t>(VT_VENDOR_ID, 0);
  }
  uint8_t product_id() const {
    return GetField<uint8_t>(VT_PRODUCT_ID, 0);
  }
  uint8_t major_rev() const {
    return GetField<uint8_t>(VT_MAJOR_REV, 0);
  }
  uint8_t minor_rev() const {
    return GetField<uint8_t>(VT_MINOR_REV, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VENDOR_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_PRODUCT_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAJOR_REV, 1) &&
           VerifyField<uint8_t>(verifier, VT_MINOR_REV, 1) &&
           verifier.EndTable();
  }
};

struct DeviceVersionBuilder {
  typedef DeviceVersion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vendor_id(uint8_t vendor_id) {
    fbb_.AddElement<uint8_t>(DeviceVersion::VT_VENDOR_ID, vendor_id, 0);
  }
  void add_product_id(uint8_t product_id) {
    fbb_.AddElement<uint8_t>(DeviceVersion::VT_PRODUCT_ID, product_id, 0);
  }
  void add_major_rev(uint8_t major_rev) {
    fbb_.AddElement<uint8_t>(DeviceVersion::VT_MAJOR_REV, major_rev, 0);
  }
  void add_minor_rev(uint8_t minor_rev) {
    fbb_.AddElement<uint8_t>(DeviceVersion::VT_MINOR_REV, minor_rev, 0);
  }
  explicit DeviceVersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceVersion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceVersion>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceVersion> CreateDeviceVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t vendor_id = 0,
    uint8_t product_id = 0,
    uint8_t major_rev = 0,
    uint8_t minor_rev = 0) {
  DeviceVersionBuilder builder_(_fbb);
  builder_.add_minor_rev(minor_rev);
  builder_.add_major_rev(major_rev);
  builder_.add_product_id(product_id);
  builder_.add_vendor_id(vendor_id);
  return builder_.Finish();
}

struct Np FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COL = 4,
    VT_ROW = 6,
    VT_ID = 8
  };
  uint8_t col() const {
    return GetField<uint8_t>(VT_COL, 0);
  }
  uint8_t row() const {
    return GetField<uint8_t>(VT_ROW, 0);
  }
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COL, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROW, 1) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           verifier.EndTable();
  }
};

struct NpBuilder {
  typedef Np Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_col(uint8_t col) {
    fbb_.AddElement<uint8_t>(Np::VT_COL, col, 0);
  }
  void add_row(uint8_t row) {
    fbb_.AddElement<uint8_t>(Np::VT_ROW, row, 0);
  }
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(Np::VT_ID, id, 0);
  }
  explicit NpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Np> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Np>(end);
    return o;
  }
};

inline flatbuffers::Offset<Np> CreateNp(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t col = 0,
    uint8_t row = 0,
    uint8_t id = 0) {
  NpBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_row(row);
  builder_.add_col(col);
  return builder_.Finish();
}

struct NpTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NpTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct NpTrackBuilder {
  typedef NpTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(NpTrack::VT_DATA, data);
  }
  explicit NpTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NpTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NpTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<NpTrack> CreateNpTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  NpTrackBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<NpTrack> CreateNpTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return akida::fb::CreateNpTrack(
      _fbb,
      data__);
}

struct Fnp2FilterTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Fnp2FilterTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NP = 4,
    VT_DATA = 6
  };
  const akida::fb::Np *np() const {
    return GetPointer<const akida::fb::Np *>(VT_NP);
  }
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NP) &&
           verifier.VerifyTable(np()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct Fnp2FilterTrackBuilder {
  typedef Fnp2FilterTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_np(flatbuffers::Offset<akida::fb::Np> np) {
    fbb_.AddOffset(Fnp2FilterTrack::VT_NP, np);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(Fnp2FilterTrack::VT_DATA, data);
  }
  explicit Fnp2FilterTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fnp2FilterTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fnp2FilterTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fnp2FilterTrack> CreateFnp2FilterTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<akida::fb::Np> np = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  Fnp2FilterTrackBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_np(np);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fnp2FilterTrack> CreateFnp2FilterTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<akida::fb::Np> np = 0,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return akida::fb::CreateFnp2FilterTrack(
      _fbb,
      np,
      data__);
}

struct EpgTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EpgTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_DATA = 6
  };
  uint32_t address() const {
    return GetField<uint32_t>(VT_ADDRESS, 0);
  }
  uint32_t data() const {
    return GetField<uint32_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ADDRESS, 4) &&
           VerifyField<uint32_t>(verifier, VT_DATA, 4) &&
           verifier.EndTable();
  }
};

struct EpgTrackBuilder {
  typedef EpgTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(uint32_t address) {
    fbb_.AddElement<uint32_t>(EpgTrack::VT_ADDRESS, address, 0);
  }
  void add_data(uint32_t data) {
    fbb_.AddElement<uint32_t>(EpgTrack::VT_DATA, data, 0);
  }
  explicit EpgTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EpgTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EpgTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<EpgTrack> CreateEpgTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t address = 0,
    uint32_t data = 0) {
  EpgTrackBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_address(address);
  return builder_.Finish();
}

struct Record FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NP_TRACKS = 4,
    VT_FNP2_TRACK = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::NpTrack>> *np_tracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::NpTrack>> *>(VT_NP_TRACKS);
  }
  const akida::fb::Fnp2FilterTrack *fnp2_track() const {
    return GetPointer<const akida::fb::Fnp2FilterTrack *>(VT_FNP2_TRACK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NP_TRACKS) &&
           verifier.VerifyVector(np_tracks()) &&
           verifier.VerifyVectorOfTables(np_tracks()) &&
           VerifyOffset(verifier, VT_FNP2_TRACK) &&
           verifier.VerifyTable(fnp2_track()) &&
           verifier.EndTable();
  }
};

struct RecordBuilder {
  typedef Record Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_np_tracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::NpTrack>>> np_tracks) {
    fbb_.AddOffset(Record::VT_NP_TRACKS, np_tracks);
  }
  void add_fnp2_track(flatbuffers::Offset<akida::fb::Fnp2FilterTrack> fnp2_track) {
    fbb_.AddOffset(Record::VT_FNP2_TRACK, fnp2_track);
  }
  explicit RecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline flatbuffers::Offset<Record> CreateRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::NpTrack>>> np_tracks = 0,
    flatbuffers::Offset<akida::fb::Fnp2FilterTrack> fnp2_track = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_fnp2_track(fnp2_track);
  builder_.add_np_tracks(np_tracks);
  return builder_.Finish();
}

inline flatbuffers::Offset<Record> CreateRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<akida::fb::NpTrack>> *np_tracks = nullptr,
    flatbuffers::Offset<akida::fb::Fnp2FilterTrack> fnp2_track = 0) {
  auto np_tracks__ = np_tracks ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::NpTrack>>(*np_tracks) : 0;
  return akida::fb::CreateRecord(
      _fbb,
      np_tracks__,
      fnp2_track);
}

struct Pass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::Record>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::Record>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct PassBuilder {
  typedef Pass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::Record>>> records) {
    fbb_.AddOffset(Pass::VT_RECORDS, records);
  }
  explicit PassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pass>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pass> CreatePass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::Record>>> records = 0) {
  PassBuilder builder_(_fbb);
  builder_.add_records(records);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pass> CreatePassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<akida::fb::Record>> *records = nullptr) {
  auto records__ = records ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::Record>>(*records) : 0;
  return akida::fb::CreatePass(
      _fbb,
      records__);
}

struct LearningLayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LearningLayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NP = 4,
    VT_LEARNING_REGISTERS = 6,
    VT_INFERENCE_REGISTERS = 8,
    VT_RAM = 10,
    VT_LEARN_MEM_SIZE = 12,
    VT_UPDATE_LEARN_MEM_HDR = 14
  };
  const akida::fb::Np *np() const {
    return GetPointer<const akida::fb::Np *>(VT_NP);
  }
  const akida::fb::Record *learning_registers() const {
    return GetPointer<const akida::fb::Record *>(VT_LEARNING_REGISTERS);
  }
  const akida::fb::Record *inference_registers() const {
    return GetPointer<const akida::fb::Record *>(VT_INFERENCE_REGISTERS);
  }
  const akida::fb::Record *ram() const {
    return GetPointer<const akida::fb::Record *>(VT_RAM);
  }
  uint32_t learn_mem_size() const {
    return GetField<uint32_t>(VT_LEARN_MEM_SIZE, 0);
  }
  const akida::fb::DmaConfigHeader *update_learn_mem_hdr() const {
    return GetStruct<const akida::fb::DmaConfigHeader *>(VT_UPDATE_LEARN_MEM_HDR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NP) &&
           verifier.VerifyTable(np()) &&
           VerifyOffset(verifier, VT_LEARNING_REGISTERS) &&
           verifier.VerifyTable(learning_registers()) &&
           VerifyOffset(verifier, VT_INFERENCE_REGISTERS) &&
           verifier.VerifyTable(inference_registers()) &&
           VerifyOffset(verifier, VT_RAM) &&
           verifier.VerifyTable(ram()) &&
           VerifyField<uint32_t>(verifier, VT_LEARN_MEM_SIZE, 4) &&
           VerifyField<akida::fb::DmaConfigHeader>(verifier, VT_UPDATE_LEARN_MEM_HDR, 4) &&
           verifier.EndTable();
  }
};

struct LearningLayerBuilder {
  typedef LearningLayer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_np(flatbuffers::Offset<akida::fb::Np> np) {
    fbb_.AddOffset(LearningLayer::VT_NP, np);
  }
  void add_learning_registers(flatbuffers::Offset<akida::fb::Record> learning_registers) {
    fbb_.AddOffset(LearningLayer::VT_LEARNING_REGISTERS, learning_registers);
  }
  void add_inference_registers(flatbuffers::Offset<akida::fb::Record> inference_registers) {
    fbb_.AddOffset(LearningLayer::VT_INFERENCE_REGISTERS, inference_registers);
  }
  void add_ram(flatbuffers::Offset<akida::fb::Record> ram) {
    fbb_.AddOffset(LearningLayer::VT_RAM, ram);
  }
  void add_learn_mem_size(uint32_t learn_mem_size) {
    fbb_.AddElement<uint32_t>(LearningLayer::VT_LEARN_MEM_SIZE, learn_mem_size, 0);
  }
  void add_update_learn_mem_hdr(const akida::fb::DmaConfigHeader *update_learn_mem_hdr) {
    fbb_.AddStruct(LearningLayer::VT_UPDATE_LEARN_MEM_HDR, update_learn_mem_hdr);
  }
  explicit LearningLayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LearningLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LearningLayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<LearningLayer> CreateLearningLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<akida::fb::Np> np = 0,
    flatbuffers::Offset<akida::fb::Record> learning_registers = 0,
    flatbuffers::Offset<akida::fb::Record> inference_registers = 0,
    flatbuffers::Offset<akida::fb::Record> ram = 0,
    uint32_t learn_mem_size = 0,
    const akida::fb::DmaConfigHeader *update_learn_mem_hdr = nullptr) {
  LearningLayerBuilder builder_(_fbb);
  builder_.add_update_learn_mem_hdr(update_learn_mem_hdr);
  builder_.add_learn_mem_size(learn_mem_size);
  builder_.add_ram(ram);
  builder_.add_inference_registers(inference_registers);
  builder_.add_learning_registers(learning_registers);
  builder_.add_np(np);
  return builder_.Finish();
}

struct Program FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_DEVICE_VERSION = 6,
    VT_INPUT_DIMS = 8,
    VT_OUTPUT_DIMS = 10,
    VT_INPUT_TYPE = 12,
    VT_OUTPUT_TYPE = 14,
    VT_ACTIVATION = 16,
    VT_DENSE_WINDOW_W = 18,
    VT_DENSE_WINDOW_H = 20,
    VT_PASSES = 22,
    VT_LEARNING_LAYER = 24,
    VT_EPG_TRACKS = 26,
    VT_SHIFTS = 28,
    VT_SCALES = 30,
    VT_DUMMY_DESC_HDR = 32,
    VT_MAX_NUM_DESC = 34
  };
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const akida::fb::DeviceVersion *device_version() const {
    return GetPointer<const akida::fb::DeviceVersion *>(VT_DEVICE_VERSION);
  }
  const flatbuffers::Vector<uint32_t> *input_dims() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUT_DIMS);
  }
  const flatbuffers::Vector<uint32_t> *output_dims() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUT_DIMS);
  }
  akida::fb::IoType input_type() const {
    return static_cast<akida::fb::IoType>(GetField<int8_t>(VT_INPUT_TYPE, 0));
  }
  akida::fb::IoType output_type() const {
    return static_cast<akida::fb::IoType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool activation() const {
    return GetField<uint8_t>(VT_ACTIVATION, 0) != 0;
  }
  uint32_t dense_window_w() const {
    return GetField<uint32_t>(VT_DENSE_WINDOW_W, 0);
  }
  uint32_t dense_window_h() const {
    return GetField<uint32_t>(VT_DENSE_WINDOW_H, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::Pass>> *passes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::Pass>> *>(VT_PASSES);
  }
  const akida::fb::LearningLayer *learning_layer() const {
    return GetPointer<const akida::fb::LearningLayer *>(VT_LEARNING_LAYER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::EpgTrack>> *epg_tracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::EpgTrack>> *>(VT_EPG_TRACKS);
  }
  const flatbuffers::Vector<int32_t> *shifts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHIFTS);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  const akida::fb::DmaConfigHeader *dummy_desc_hdr() const {
    return GetStruct<const akida::fb::DmaConfigHeader *>(VT_DUMMY_DESC_HDR);
  }
  uint8_t max_num_desc() const {
    return GetField<uint8_t>(VT_MAX_NUM_DESC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_DEVICE_VERSION) &&
           verifier.VerifyTable(device_version()) &&
           VerifyOffset(verifier, VT_INPUT_DIMS) &&
           verifier.VerifyVector(input_dims()) &&
           VerifyOffset(verifier, VT_OUTPUT_DIMS) &&
           verifier.VerifyVector(output_dims()) &&
           VerifyField<int8_t>(verifier, VT_INPUT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVATION, 1) &&
           VerifyField<uint32_t>(verifier, VT_DENSE_WINDOW_W, 4) &&
           VerifyField<uint32_t>(verifier, VT_DENSE_WINDOW_H, 4) &&
           VerifyOffset(verifier, VT_PASSES) &&
           verifier.VerifyVector(passes()) &&
           verifier.VerifyVectorOfTables(passes()) &&
           VerifyOffset(verifier, VT_LEARNING_LAYER) &&
           verifier.VerifyTable(learning_layer()) &&
           VerifyOffset(verifier, VT_EPG_TRACKS) &&
           verifier.VerifyVector(epg_tracks()) &&
           verifier.VerifyVectorOfTables(epg_tracks()) &&
           VerifyOffset(verifier, VT_SHIFTS) &&
           verifier.VerifyVector(shifts()) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyField<akida::fb::DmaConfigHeader>(verifier, VT_DUMMY_DESC_HDR, 4) &&
           VerifyField<uint8_t>(verifier, VT_MAX_NUM_DESC, 1) &&
           verifier.EndTable();
  }
};

struct ProgramBuilder {
  typedef Program Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(Program::VT_VERSION, version);
  }
  void add_device_version(flatbuffers::Offset<akida::fb::DeviceVersion> device_version) {
    fbb_.AddOffset(Program::VT_DEVICE_VERSION, device_version);
  }
  void add_input_dims(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> input_dims) {
    fbb_.AddOffset(Program::VT_INPUT_DIMS, input_dims);
  }
  void add_output_dims(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> output_dims) {
    fbb_.AddOffset(Program::VT_OUTPUT_DIMS, output_dims);
  }
  void add_input_type(akida::fb::IoType input_type) {
    fbb_.AddElement<int8_t>(Program::VT_INPUT_TYPE, static_cast<int8_t>(input_type), 0);
  }
  void add_output_type(akida::fb::IoType output_type) {
    fbb_.AddElement<int8_t>(Program::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  void add_activation(bool activation) {
    fbb_.AddElement<uint8_t>(Program::VT_ACTIVATION, static_cast<uint8_t>(activation), 0);
  }
  void add_dense_window_w(uint32_t dense_window_w) {
    fbb_.AddElement<uint32_t>(Program::VT_DENSE_WINDOW_W, dense_window_w, 0);
  }
  void add_dense_window_h(uint32_t dense_window_h) {
    fbb_.AddElement<uint32_t>(Program::VT_DENSE_WINDOW_H, dense_window_h, 0);
  }
  void add_passes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::Pass>>> passes) {
    fbb_.AddOffset(Program::VT_PASSES, passes);
  }
  void add_learning_layer(flatbuffers::Offset<akida::fb::LearningLayer> learning_layer) {
    fbb_.AddOffset(Program::VT_LEARNING_LAYER, learning_layer);
  }
  void add_epg_tracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::EpgTrack>>> epg_tracks) {
    fbb_.AddOffset(Program::VT_EPG_TRACKS, epg_tracks);
  }
  void add_shifts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shifts) {
    fbb_.AddOffset(Program::VT_SHIFTS, shifts);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(Program::VT_SCALES, scales);
  }
  void add_dummy_desc_hdr(const akida::fb::DmaConfigHeader *dummy_desc_hdr) {
    fbb_.AddStruct(Program::VT_DUMMY_DESC_HDR, dummy_desc_hdr);
  }
  void add_max_num_desc(uint8_t max_num_desc) {
    fbb_.AddElement<uint8_t>(Program::VT_MAX_NUM_DESC, max_num_desc, 0);
  }
  explicit ProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Program> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Program>(end);
    return o;
  }
};

inline flatbuffers::Offset<Program> CreateProgram(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<akida::fb::DeviceVersion> device_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> input_dims = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> output_dims = 0,
    akida::fb::IoType input_type = akida::fb::IoType_dense,
    akida::fb::IoType output_type = akida::fb::IoType_dense,
    bool activation = false,
    uint32_t dense_window_w = 0,
    uint32_t dense_window_h = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::Pass>>> passes = 0,
    flatbuffers::Offset<akida::fb::LearningLayer> learning_layer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::EpgTrack>>> epg_tracks = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shifts = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0,
    const akida::fb::DmaConfigHeader *dummy_desc_hdr = nullptr,
    uint8_t max_num_desc = 0) {
  ProgramBuilder builder_(_fbb);
  builder_.add_dummy_desc_hdr(dummy_desc_hdr);
  builder_.add_scales(scales);
  builder_.add_shifts(shifts);
  builder_.add_epg_tracks(epg_tracks);
  builder_.add_learning_layer(learning_layer);
  builder_.add_passes(passes);
  builder_.add_dense_window_h(dense_window_h);
  builder_.add_dense_window_w(dense_window_w);
  builder_.add_output_dims(output_dims);
  builder_.add_input_dims(input_dims);
  builder_.add_device_version(device_version);
  builder_.add_version(version);
  builder_.add_max_num_desc(max_num_desc);
  builder_.add_activation(activation);
  builder_.add_output_type(output_type);
  builder_.add_input_type(input_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Program> CreateProgramDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    flatbuffers::Offset<akida::fb::DeviceVersion> device_version = 0,
    const std::vector<uint32_t> *input_dims = nullptr,
    const std::vector<uint32_t> *output_dims = nullptr,
    akida::fb::IoType input_type = akida::fb::IoType_dense,
    akida::fb::IoType output_type = akida::fb::IoType_dense,
    bool activation = false,
    uint32_t dense_window_w = 0,
    uint32_t dense_window_h = 0,
    const std::vector<flatbuffers::Offset<akida::fb::Pass>> *passes = nullptr,
    flatbuffers::Offset<akida::fb::LearningLayer> learning_layer = 0,
    const std::vector<flatbuffers::Offset<akida::fb::EpgTrack>> *epg_tracks = nullptr,
    const std::vector<int32_t> *shifts = nullptr,
    const std::vector<float> *scales = nullptr,
    const akida::fb::DmaConfigHeader *dummy_desc_hdr = nullptr,
    uint8_t max_num_desc = 0) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto input_dims__ = input_dims ? _fbb.CreateVector<uint32_t>(*input_dims) : 0;
  auto output_dims__ = output_dims ? _fbb.CreateVector<uint32_t>(*output_dims) : 0;
  auto passes__ = passes ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::Pass>>(*passes) : 0;
  auto epg_tracks__ = epg_tracks ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::EpgTrack>>(*epg_tracks) : 0;
  auto shifts__ = shifts ? _fbb.CreateVector<int32_t>(*shifts) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return akida::fb::CreateProgram(
      _fbb,
      version__,
      device_version,
      input_dims__,
      output_dims__,
      input_type,
      output_type,
      activation,
      dense_window_w,
      dense_window_h,
      passes__,
      learning_layer,
      epg_tracks__,
      shifts__,
      scales__,
      dummy_desc_hdr,
      max_num_desc);
}

inline const akida::fb::Program *GetProgram(const void *buf) {
  return flatbuffers::GetRoot<akida::fb::Program>(buf);
}

inline const akida::fb::Program *GetSizePrefixedProgram(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<akida::fb::Program>(buf);
}

inline bool VerifyProgramBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<akida::fb::Program>(nullptr);
}

inline bool VerifySizePrefixedProgramBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<akida::fb::Program>(nullptr);
}

inline void FinishProgramBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<akida::fb::Program> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProgramBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<akida::fb::Program> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fb
}  // namespace akida

#endif  // FLATBUFFERS_GENERATED_AKIDADEVICEPROGRAMFB_AKIDA_FB_H_
