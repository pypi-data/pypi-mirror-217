# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Tell mypy (a type checker) to ignore all errors from this file.
# See https://mypy.readthedocs.io/en/stable/config_file.html?highlight=ignore-errors#confval-ignore_errors
# mypy: ignore-errors

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_zcash_e53_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_zcash_e53_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_zcash_e53_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder():
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer after consuming")
        finally:
            self.free()


class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream(object):
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, rbuf):
        self.rbuf = rbuf
        self.offset = 0

    def remaining(self):
        return self.rbuf.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        data = self.rbuf.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")


class RustBufferBuilder(object):
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        return result
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, RustBuffer, ctypes.POINTER(RustBuffer))
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
#
# XXX TODO: This will probably grow some magic for resolving megazording in future.
# E.g. we might start by looking for the named component in `libuniffi.so` and if
# that fails, fall back to loading it separately from `lib${componentName}.so`.

from pathlib import Path

def loadIndirect():
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    lib = libname.format("uniffi_zcash")
    path = str(Path(__file__).parent / lib)
    return ctypes.cdll.LoadLibrary(path)

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.ffi_zcash_e53_ZcashRecipientAddress_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashRecipientAddress_object_free.restype = None
_UniFFILib.zcash_e53_ZcashRecipientAddress_decode.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashRecipientAddress_decode.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashRecipientAddress_shielded.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashRecipientAddress_shielded.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashRecipientAddress_transparent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashRecipientAddress_transparent.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashRecipientAddress_unified.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashRecipientAddress_unified.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashRecipientAddress_encode.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashRecipientAddress_encode.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashUnifiedAddress_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashUnifiedAddress_object_free.restype = None
_UniFFILib.zcash_e53_ZcashUnifiedAddress_new.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedAddress_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedAddress_decode.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedAddress_decode.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedAddress_orchard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedAddress_orchard.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedAddress_sapling.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedAddress_sapling.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedAddress_transparent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedAddress_transparent.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedAddress_encode.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedAddress_encode.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashUnifiedFullViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashUnifiedFullViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_new.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_decode.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_decode.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_encode.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_encode.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_transparent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_transparent.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_sapling.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_sapling.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_orchard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_orchard.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_find_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_find_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_default_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_default_address.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashUnifiedSpendingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashUnifiedSpendingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_from_seed.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_from_seed.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_from_bytes.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_to_unified_full_viewing_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_to_unified_full_viewing_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_transparent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_transparent.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_sapling.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_sapling.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_orchard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_orchard.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardNote_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardNote_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardNote_from_parts.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNote_from_parts.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardNote_recipient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNote_recipient.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardNote_value.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNote_value.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardNote_commitment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNote_commitment.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashOrchardNullifier_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardNullifier_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardNullifier_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNullifier_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardNullifier_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNullifier_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardRandomSeed_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardRandomSeed_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardRandomSeed_from_bytes.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardRandomSeed_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardRandomSeed_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardRandomSeed_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardNoteCommitment_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardNoteCommitment_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardNoteCommitment_to_extracted_note_commitment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNoteCommitment_to_extracted_note_commitment.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashExtractedNoteCommitment_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashExtractedNoteCommitment_object_free.restype = None
_UniFFILib.zcash_e53_ZcashExtractedNoteCommitment_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtractedNoteCommitment_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtractedNoteCommitment_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtractedNoteCommitment_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardAddress_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardAddress_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardAddress_from_raw_address_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardAddress_from_raw_address_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardAddress_diversifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardAddress_diversifier.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardAddress_to_raw_address_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardAddress_to_raw_address_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashVerifyingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashVerifyingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashVerifyingKey_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashVerifyingKey_new.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashProvingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashProvingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashProvingKey_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashProvingKey_new.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashOrchardBundle_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardBundle_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardBundle_actions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_actions.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardBundle_flags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_flags.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardBundle_value_balance.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_value_balance.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardBundle_anchor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_anchor.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardBundle_verify_proof.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_verify_proof.restype = None
_UniFFILib.zcash_e53_ZcashOrchardBundle_decrypt_output_with_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_decrypt_output_with_key.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardBundle_decrypt_output_with_keys.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_decrypt_output_with_keys.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardBundle_recover_output_with_ovk.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_recover_output_with_ovk.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardBundle_recover_outputs_with_ovks.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardBundle_recover_outputs_with_ovks.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardFlags_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardFlags_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardFlags_from_parts.argtypes = (
    ctypes.c_int8,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFlags_from_parts.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardFlags_from_byte.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFlags_from_byte.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardFlags_spends_enabled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFlags_spends_enabled.restype = ctypes.c_int8
_UniFFILib.zcash_e53_ZcashOrchardFlags_outputs_enabled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFlags_outputs_enabled.restype = ctypes.c_int8
_UniFFILib.zcash_e53_ZcashOrchardFlags_to_byte.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFlags_to_byte.restype = ctypes.c_uint8
_UniFFILib.ffi_zcash_e53_ZcashOrchardNoteValue_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardNoteValue_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardNoteValue_from_raw.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNoteValue_from_raw.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardNoteValue_value.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardNoteValue_value.restype = ctypes.c_uint64
_UniFFILib.ffi_zcash_e53_ZcashOrchardValueCommitment_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardValueCommitment_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardValueCommitment_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardValueCommitment_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardAction_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardAction_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardAction_nullifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardAction_nullifier.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardAction_cmx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardAction_cmx.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardAction_encrypted_note.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardAction_encrypted_note.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardAction_cv_net.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardAction_cv_net.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashOrchardFullViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardFullViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_address_at.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_address_at.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_address.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_scope_for_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_scope_for_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_ivk.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_ivk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_ovk.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_ovk.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashOrchardSpendingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardSpendingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_from_zip32_seed.argtypes = (
    RustBuffer,
    ctypes.c_uint32,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_from_zip32_seed.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_to_fvk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_to_fvk.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashAnchor_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashAnchor_object_free.restype = None
_UniFFILib.zcash_e53_ZcashAnchor_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAnchor_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAnchor_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAnchor_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardIncomingViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardIncomingViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_diversifier_index.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_diversifier_index.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_address_at.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_address_at.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_address.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashOrchardDiversifier_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardDiversifier_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardDiversifier_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardDiversifier_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardDiversifier_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardDiversifier_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardOutgoingViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardOutgoingViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardOutgoingViewingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardOutgoingViewingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardOutgoingViewingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardOutgoingViewingKey_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardMerklePath_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardMerklePath_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardMerklePath_from_parts.argtypes = (
    ctypes.c_uint32,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardMerklePath_from_parts.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardMerklePath_root.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardMerklePath_root.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashOrchardMerkleHash_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardMerkleHash_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_from_cmx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_from_cmx.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardDiversifierIndex_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardDiversifierIndex_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_u32.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_u32.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_u64.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashExtendedPrivKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashExtendedPrivKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_random.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_random.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_random_with_seed_size.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_random_with_seed_size.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_with_seed.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_with_seed.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_derive_private_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedPrivKey_derive_private_key.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashKeyIndex_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashKeyIndex_object_free.restype = None
_UniFFILib.zcash_e53_ZcashKeyIndex_from_u32.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashKeyIndex_from_u32.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashKeyIndex_hardened_from_normalize_index.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashKeyIndex_hardened_from_normalize_index.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashKeyIndex_from_index.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashKeyIndex_from_index.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashKeyIndex_raw_index.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashKeyIndex_raw_index.restype = ctypes.c_uint32
_UniFFILib.zcash_e53_ZcashKeyIndex_normalize_index.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashKeyIndex_normalize_index.restype = ctypes.c_uint32
_UniFFILib.zcash_e53_ZcashKeyIndex_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashKeyIndex_is_valid.restype = ctypes.c_int8
_UniFFILib.ffi_zcash_e53_ZcashZip317FeeRule_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashZip317FeeRule_object_free.restype = None
_UniFFILib.zcash_e53_ZcashZip317FeeRule_standard.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashZip317FeeRule_standard.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashZip317FeeRule_non_standard.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashZip317FeeRule_non_standard.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashZip317FeeRule_marginal_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashZip317FeeRule_marginal_fee.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashFixedFeeRule_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashFixedFeeRule_object_free.restype = None
_UniFFILib.zcash_e53_ZcashFixedFeeRule_non_standard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashFixedFeeRule_non_standard.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashFixedFeeRule_standard.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashFixedFeeRule_standard.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashFixedFeeRule_fixed_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashFixedFeeRule_fixed_fee.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashTransparentBundle_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashTransparentBundle_object_free.restype = None
_UniFFILib.zcash_e53_ZcashTransparentBundle_is_coinbase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentBundle_is_coinbase.restype = ctypes.c_int8
_UniFFILib.zcash_e53_ZcashTransparentBundle_vin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentBundle_vin.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTransparentBundle_vout.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentBundle_vout.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashTxOut_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashTxOut_object_free.restype = None
_UniFFILib.zcash_e53_ZcashTxOut_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxOut_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTxOut_value.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxOut_value.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTxOut_script_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxOut_script_pubkey.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTxOut_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxOut_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTxOut_recipient_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxOut_recipient_address.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashTxIn_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashTxIn_object_free.restype = None
_UniFFILib.zcash_e53_ZcashTxIn_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxIn_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashTransactionBuilder_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashTransactionBuilder_object_free.restype = None
_UniFFILib.zcash_e53_ZcashTransactionBuilder_new.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransactionBuilder_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_sapling_spend.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_sapling_spend.restype = None
_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_sapling_output.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_sapling_output.restype = None
_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_transparent_input.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_transparent_input.restype = None
_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_transparent_output.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_transparent_output.restype = None
_UniFFILib.zcash_e53_ZcashTransactionBuilder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransactionBuilder_build.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashTransaction_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashTransaction_object_free.restype = None
_UniFFILib.zcash_e53_ZcashTransaction_from_bytes.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransaction_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTransaction_txid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_txid.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransaction_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_version.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransaction_consensus_branch_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_consensus_branch_id.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTransaction_lock_time.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_lock_time.restype = ctypes.c_uint32
_UniFFILib.zcash_e53_ZcashTransaction_expiry_height.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_expiry_height.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransaction_transparent_bundle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_transparent_bundle.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTransaction_sapling_bundle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_sapling_bundle.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTransaction_orchard_bundle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransaction_orchard_bundle.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashTxId_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashTxId_object_free.restype = None
_UniFFILib.zcash_e53_ZcashTxId_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxId_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTxId_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxId_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOrchardTransactionBuilder_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOrchardTransactionBuilder_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_new.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_add_spend.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_add_spend.restype = None
_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_add_recipient.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.c_uint64,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_add_recipient.restype = None
_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_build.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_build.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashTxVersion_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashTxVersion_object_free.restype = None
_UniFFILib.zcash_e53_ZcashTxVersion_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTxVersion_suggested_for_branch.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_suggested_for_branch.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTxVersion_selection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_selection.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTxVersion_header.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_header.restype = ctypes.c_uint32
_UniFFILib.zcash_e53_ZcashTxVersion_version_group_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_version_group_id.restype = ctypes.c_uint32
_UniFFILib.zcash_e53_ZcashTxVersion_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTxVersion_has_sprout.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_has_sprout.restype = ctypes.c_int8
_UniFFILib.zcash_e53_ZcashTxVersion_has_overwinter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_has_overwinter.restype = ctypes.c_int8
_UniFFILib.zcash_e53_ZcashTxVersion_has_sapling.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_has_sapling.restype = ctypes.c_int8
_UniFFILib.zcash_e53_ZcashTxVersion_has_orchard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTxVersion_has_orchard.restype = ctypes.c_int8
_UniFFILib.ffi_zcash_e53_ZcashOutPoint_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOutPoint_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOutPoint_new.argtypes = (
    RustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOutPoint_new.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashAmount_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashAmount_object_free.restype = None
_UniFFILib.zcash_e53_ZcashAmount_new.argtypes = (
    ctypes.c_int64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAmount_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAmount_zero.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAmount_zero.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAmount_value.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAmount_value.restype = ctypes.c_int64
_UniFFILib.ffi_zcash_e53_ZcashSaplingSpendDescription_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingSpendDescription_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_cv.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_cv.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_anchor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_anchor.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_nullifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_nullifier.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_rk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_rk.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashSaplingBundle_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingBundle_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingBundle_shielded_spends.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingBundle_shielded_spends.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashSaplingBundle_shielded_outputs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingBundle_shielded_outputs.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashSaplingBundle_value_balance.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingBundle_value_balance.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashSaplingOutputDescription_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingOutputDescription_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingOutputDescription_cv.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingOutputDescription_cv.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashSaplingOutputDescription_cmu.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingOutputDescription_cmu.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashSaplingMetadata_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingMetadata_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingMetadata_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingMetadata_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashSaplingMetadata_spend_index.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingMetadata_spend_index.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashSaplingMetadata_output_index.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingMetadata_output_index.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashBlockHeight_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashBlockHeight_object_free.restype = None
_UniFFILib.zcash_e53_ZcashBlockHeight_new.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashBlockHeight_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashBlockHeight_value.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashBlockHeight_value.restype = ctypes.c_uint32
_UniFFILib.ffi_zcash_e53_ZcashCommitmentTree_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashCommitmentTree_object_free.restype = None
_UniFFILib.zcash_e53_ZcashCommitmentTree_empty.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashCommitmentTree_empty.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashCommitmentTree_append.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashCommitmentTree_append.restype = None
_UniFFILib.ffi_zcash_e53_ZcashSaplingMerklePath_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingMerklePath_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingMerklePath_auth_path.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingMerklePath_auth_path.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashSaplingMerklePath_position.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingMerklePath_position.restype = ctypes.c_uint64
_UniFFILib.ffi_zcash_e53_ZcashIncrementalWitness_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashIncrementalWitness_object_free.restype = None
_UniFFILib.zcash_e53_ZcashIncrementalWitness_from_tree.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashIncrementalWitness_from_tree.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashIncrementalWitness_append.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashIncrementalWitness_append.restype = None
_UniFFILib.zcash_e53_ZcashIncrementalWitness_path.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashIncrementalWitness_path.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashTransparentAddress_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashTransparentAddress_object_free.restype = None
_UniFFILib.zcash_e53_ZcashTransparentAddress_from_public_key.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentAddress_from_public_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransparentAddress_from_script.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentAddress_from_script.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransparentAddress_decode.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentAddress_decode.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransparentAddress_encode.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentAddress_encode.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashTransparentAddress_is_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentAddress_is_public_key.restype = ctypes.c_int8
_UniFFILib.zcash_e53_ZcashTransparentAddress_is_script.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentAddress_is_script.restype = ctypes.c_int8
_UniFFILib.zcash_e53_ZcashTransparentAddress_script.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentAddress_script.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashTransparentAddress_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashTransparentAddress_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashExternalIvk_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashExternalIvk_object_free.restype = None
_UniFFILib.zcash_e53_ZcashExternalIvk_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExternalIvk_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExternalIvk_derive_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExternalIvk_derive_address.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExternalIvk_default_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExternalIvk_default_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExternalIvk_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExternalIvk_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashInternalIvk_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashInternalIvk_object_free.restype = None
_UniFFILib.zcash_e53_ZcashInternalIvk_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashInternalIvk_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashInternalIvk_default_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashInternalIvk_default_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashInternalIvk_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashInternalIvk_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashExternalOvk_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashExternalOvk_object_free.restype = None
_UniFFILib.zcash_e53_ZcashExternalOvk_as_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExternalOvk_as_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashInternalOvk_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashInternalOvk_object_free.restype = None
_UniFFILib.zcash_e53_ZcashInternalOvk_as_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashInternalOvk_as_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashAccountPubKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashAccountPubKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashAccountPubKey_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPubKey_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPubKey_derive_external_ivk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPubKey_derive_external_ivk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPubKey_derive_internal_ivk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPubKey_derive_internal_ivk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPubKey_ovks_for_shielding.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPubKey_ovks_for_shielding.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashAccountPubKey_internal_ovk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPubKey_internal_ovk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPubKey_external_ovk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPubKey_external_ovk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPubKey_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPubKey_serialize.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashAccountPrivKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashAccountPrivKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_seed.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_seed.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_extended_privkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_extended_privkey.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPrivKey_to_account_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPrivKey_to_account_pubkey.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPrivKey_derive_external_secret_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPrivKey_derive_external_secret_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPrivKey_derive_internal_secret_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPrivKey_derive_internal_secret_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashAccountPrivKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashAccountPrivKey_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashScript_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashScript_object_free.restype = None
_UniFFILib.zcash_e53_ZcashScript_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashScript_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashScript_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashScript_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashSaplingValueCommitment_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingValueCommitment_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingValueCommitment_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingValueCommitment_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashSaplingNote_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingNote_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingNote_from_parts.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingNote_from_parts.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashSaplingNote_value.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingNote_value.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashSaplingNote_cmu.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingNote_cmu.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashSaplingNoteValue_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingNoteValue_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingNoteValue_from_raw.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingNoteValue_from_raw.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashSaplingNoteValue_inner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingNoteValue_inner.restype = ctypes.c_uint64
_UniFFILib.ffi_zcash_e53_ZcashSaplingNullifier_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingNullifier_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingNullifier_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingNullifier_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashSaplingExtractedNoteCommitment_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingExtractedNoteCommitment_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingExtractedNoteCommitment_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingExtractedNoteCommitment_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashSaplingExtractedNoteCommitment_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingExtractedNoteCommitment_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashPaymentAddress_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashPaymentAddress_object_free.restype = None
_UniFFILib.zcash_e53_ZcashPaymentAddress_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashPaymentAddress_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashPaymentAddress_decode.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashPaymentAddress_decode.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashPaymentAddress_encode.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashPaymentAddress_encode.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashPaymentAddress_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashPaymentAddress_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashPaymentAddress_diversifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashPaymentAddress_diversifier.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashPaymentAddress_pk_d.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashPaymentAddress_pk_d.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashPaymentAddress_create_note.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashPaymentAddress_create_note.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashSaplingIvk_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingIvk_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingIvk_to_payment_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingIvk_to_payment_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashSaplingIvk_to_repr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingIvk_to_repr.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashDiversifier_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashDiversifier_object_free.restype = None
_UniFFILib.zcash_e53_ZcashDiversifier_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifier_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifier_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifier_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashFullViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashFullViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashFullViewingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashFullViewingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashFullViewingKey_from_expanded_spending_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashFullViewingKey_from_expanded_spending_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashFullViewingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashFullViewingKey_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashFullViewingKey_vk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashFullViewingKey_vk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashFullViewingKey_ovk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashFullViewingKey_ovk.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashNullifierDerivingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashNullifierDerivingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashNullifierDerivingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashNullifierDerivingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashNullifierDerivingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashNullifierDerivingKey_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashOutgoingViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashOutgoingViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashOutgoingViewingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOutgoingViewingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashOutgoingViewingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashOutgoingViewingKey_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashExpandedSpendingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashExpandedSpendingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_from_spending_key.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_from_spending_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_proof_generation_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_proof_generation_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashProofGenerationKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashProofGenerationKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashProofGenerationKey_to_viewing_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashProofGenerationKey_to_viewing_key.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashDiversifiableFullViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashDiversifiableFullViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_fvk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_fvk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_nk.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_nk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_ivk.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_ivk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_ovk.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_ovk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_find_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_find_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_default_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_default_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_diversified_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_diversified_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_change_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_change_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_diversified_change_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_diversified_change_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_decrypt_diversifier.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_decrypt_diversifier.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashSaplingDiversifiedTransmissionKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingDiversifiedTransmissionKey_object_free.restype = None
_UniFFILib.ffi_zcash_e53_ZcashViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashViewingKey_ivk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashViewingKey_ivk.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashViewingKey_to_payment_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashViewingKey_to_payment_address.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashExtendedFullViewingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashExtendedFullViewingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_decode.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_decode.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_encode.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_encode.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_derive_child.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_derive_child.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_find_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_find_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_default_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_default_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_derive_internal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_derive_internal.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashSaplingPublicKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingPublicKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingPublicKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingPublicKey_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashSaplingNode_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashSaplingNode_object_free.restype = None
_UniFFILib.zcash_e53_ZcashSaplingNode_from_cmu.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashSaplingNode_from_cmu.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashExtendedSpendingKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashExtendedSpendingKey_object_free.restype = None
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_master.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_master.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_from_path.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_from_path.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_decode.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_decode.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_encode.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_encode.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_to_bytes.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_derive_child.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_derive_child.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_default_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_default_address.restype = RustBuffer
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_derive_internal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_derive_internal.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_ZcashDiversifierIndex_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashDiversifierIndex_object_free.restype = None
_UniFFILib.zcash_e53_ZcashDiversifierIndex_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifierIndex_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifierIndex_from_u32.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifierIndex_from_u32.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifierIndex_from_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifierIndex_from_u64.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashDiversifierIndex_increment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifierIndex_increment.restype = None
_UniFFILib.zcash_e53_ZcashDiversifierIndex_to_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifierIndex_to_u32.restype = ctypes.c_uint32
_UniFFILib.zcash_e53_ZcashDiversifierIndex_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashDiversifierIndex_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashMemoBytes_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashMemoBytes_object_free.restype = None
_UniFFILib.zcash_e53_ZcashMemoBytes_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashMemoBytes_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashMemoBytes_empty.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashMemoBytes_empty.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashMemoBytes_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashMemoBytes_data.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashLocalTxProver_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashLocalTxProver_object_free.restype = None
_UniFFILib.zcash_e53_ZcashLocalTxProver_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashLocalTxProver_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashLocalTxProver_from_bytes.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashLocalTxProver_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashLocalTxProver_with_default_location.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashLocalTxProver_with_default_location.restype = ctypes.c_void_p
_UniFFILib.ffi_zcash_e53_SecpSecretKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_SecpSecretKey_object_free.restype = None
_UniFFILib.zcash_e53_SecpSecretKey_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_SecpSecretKey_new.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_SecpSecretKey_serialize_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_SecpSecretKey_serialize_secret.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_ZcashJubjubFr_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_ZcashJubjubFr_object_free.restype = None
_UniFFILib.zcash_e53_ZcashJubjubFr_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashJubjubFr_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_ZcashJubjubFr_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_ZcashJubjubFr_to_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_TestSupport_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_TestSupport_object_free.restype = None
_UniFFILib.zcash_e53_TestSupport_from_csv_file.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_TestSupport_from_csv_file.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_TestSupport_get_as_u8_array.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_TestSupport_get_as_u8_array.restype = RustBuffer
_UniFFILib.zcash_e53_TestSupport_get_as_u32_array.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_TestSupport_get_as_u32_array.restype = RustBuffer
_UniFFILib.zcash_e53_TestSupport_get_as_u64_array.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_TestSupport_get_as_u64_array.restype = RustBuffer
_UniFFILib.zcash_e53_TestSupport_get_as_u32.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_TestSupport_get_as_u32.restype = ctypes.c_uint32
_UniFFILib.zcash_e53_TestSupport_get_as_u64.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_TestSupport_get_as_u64.restype = ctypes.c_uint64
_UniFFILib.zcash_e53_TestSupport_get_as_string.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_TestSupport_get_as_string.restype = RustBuffer
_UniFFILib.zcash_e53_decode_extended_full_viewing_key.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_decode_extended_full_viewing_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_decode_extended_spending_key.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_decode_extended_spending_key.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_decode_payment_address.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_decode_payment_address.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_decode_transparent_address.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_decode_transparent_address.restype = ctypes.c_void_p
_UniFFILib.zcash_e53_encode_extended_full_viewing_key.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_encode_extended_full_viewing_key.restype = RustBuffer
_UniFFILib.zcash_e53_encode_extended_spending_key.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_encode_extended_spending_key.restype = RustBuffer
_UniFFILib.zcash_e53_encode_payment_address.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_encode_payment_address.restype = RustBuffer
_UniFFILib.zcash_e53_encode_payment_address_p.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_encode_payment_address_p.restype = RustBuffer
_UniFFILib.zcash_e53_encode_transparent_address.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_encode_transparent_address.restype = RustBuffer
_UniFFILib.zcash_e53_encode_transparent_address_p.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zcash_e53_encode_transparent_address_p.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_zcash_e53_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_rustbuffer_free.restype = None
_UniFFILib.ffi_zcash_e53_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zcash_e53_rustbuffer_reserve.restype = RustBuffer

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def write(value, buf):
        buf.writeU8(value)

class FfiConverterUInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def write(value, buf):
        buf.writeU32(value)

class FfiConverterUInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def write(value, buf):
        buf.writeU64(value)

class FfiConverterInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI64()

    @staticmethod
    def write(value, buf):
        buf.writeI64(value)

class FfiConverterBool:
    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def write(cls, value, buf):
        buf.writeU8(cls.lower(value))

    @staticmethod
    def lift(value):
        return int(value) != 0

    @staticmethod
    def lower(value):
        return 1 if value else 0

class FfiConverterString:
    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class SecpSecretKey(object): 
    def __init__(self, data):
        data = list(int(x) for x in data)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_SecpSecretKey_new,
        FfiConverterSequenceUInt8.lower(data))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_SecpSecretKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def serialize_secret(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_SecpSecretKey_serialize_secret,self._pointer,)
        )
    


class FfiConverterTypeSecpSecretKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SecpSecretKey):
            raise TypeError("Expected SecpSecretKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SecpSecretKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TestSupport(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_TestSupport_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_csv_file(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_TestSupport_from_csv_file,)
        return cls._make_instance_(pointer)
    

    def get_as_u8_array(self, key):
        key = key
        
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_TestSupport_get_as_u8_array,self._pointer,
        FfiConverterString.lower(key))
        )
    def get_as_u32_array(self, key):
        key = key
        
        return FfiConverterSequenceUInt32.lift(
            rust_call(_UniFFILib.zcash_e53_TestSupport_get_as_u32_array,self._pointer,
        FfiConverterString.lower(key))
        )
    def get_as_u64_array(self, key):
        key = key
        
        return FfiConverterSequenceUInt64.lift(
            rust_call(_UniFFILib.zcash_e53_TestSupport_get_as_u64_array,self._pointer,
        FfiConverterString.lower(key))
        )
    def get_as_u32(self, key):
        key = key
        
        return FfiConverterUInt32.lift(
            rust_call(_UniFFILib.zcash_e53_TestSupport_get_as_u32,self._pointer,
        FfiConverterString.lower(key))
        )
    def get_as_u64(self, key):
        key = key
        
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.zcash_e53_TestSupport_get_as_u64,self._pointer,
        FfiConverterString.lower(key))
        )
    def get_as_string(self, key):
        key = key
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zcash_e53_TestSupport_get_as_string,self._pointer,
        FfiConverterString.lower(key))
        )
    


class FfiConverterTypeTestSupport:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TestSupport):
            raise TypeError("Expected TestSupport instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TestSupport._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashAccountPrivKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashAccountPrivKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_seed(cls, params,seed,account_id):
        params = params
        
        seed = list(int(x) for x in seed)
        
        account_id = account_id
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_seed,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterSequenceUInt8.lower(seed),
        FfiConverterTypeZcashAccountId.lower(account_id))
        return cls._make_instance_(pointer)
    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    @classmethod
    def from_extended_privkey(cls, key):
        key = key
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashAccountPrivKey_from_extended_privkey,
        FfiConverterTypeZcashExtendedPrivKey.lower(key))
        return cls._make_instance_(pointer)
    

    def to_account_pubkey(self, ):
        return FfiConverterTypeZcashAccountPubKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashAccountPrivKey_to_account_pubkey,self._pointer,)
        )
    def derive_external_secret_key(self, child_index):
        child_index = int(child_index)
        
        return FfiConverterTypeSecpSecretKey.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAccountPrivKey_derive_external_secret_key,self._pointer,
        FfiConverterUInt32.lower(child_index))
        )
    def derive_internal_secret_key(self, child_index):
        child_index = int(child_index)
        
        return FfiConverterTypeSecpSecretKey.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAccountPrivKey_derive_internal_secret_key,self._pointer,
        FfiConverterUInt32.lower(child_index))
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashAccountPrivKey_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashAccountPrivKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashAccountPrivKey):
            raise TypeError("Expected ZcashAccountPrivKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashAccountPrivKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashAccountPubKey(object): 
    def __init__(self, data):
        data = list(int(x) for x in data)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAccountPubKey_new,
        FfiConverterSequenceUInt8.lower(data))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashAccountPubKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def derive_external_ivk(self, ):
        return FfiConverterTypeZcashExternalIvk.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAccountPubKey_derive_external_ivk,self._pointer,)
        )
    def derive_internal_ivk(self, ):
        return FfiConverterTypeZcashInternalIvk.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAccountPubKey_derive_internal_ivk,self._pointer,)
        )
    def ovks_for_shielding(self, ):
        return FfiConverterTypeZcashInternalOvkExternalOvk.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashAccountPubKey_ovks_for_shielding,self._pointer,)
        )
    def internal_ovk(self, ):
        return FfiConverterTypeZcashInternalOvk.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashAccountPubKey_internal_ovk,self._pointer,)
        )
    def external_ovk(self, ):
        return FfiConverterTypeZcashExternalOvk.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashAccountPubKey_external_ovk,self._pointer,)
        )
    def serialize(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashAccountPubKey_serialize,self._pointer,)
        )
    


class FfiConverterTypeZcashAccountPubKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashAccountPubKey):
            raise TypeError("Expected ZcashAccountPubKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashAccountPubKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashAmount(object): 
    def __init__(self, amount):
        amount = int(amount)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAmount_new,
        FfiConverterInt64.lower(amount))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashAmount_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def zero(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashAmount_zero,)
        return cls._make_instance_(pointer)
    

    def value(self, ):
        return FfiConverterInt64.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashAmount_value,self._pointer,)
        )
    


class FfiConverterTypeZcashAmount:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashAmount):
            raise TypeError("Expected ZcashAmount instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashAmount._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashAnchor(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashAnchor_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashAnchor_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashAnchor_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashAnchor:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashAnchor):
            raise TypeError("Expected ZcashAnchor instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashAnchor._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashBlockHeight(object): 
    def __init__(self, v):
        v = int(v)
        
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashBlockHeight_new,
        FfiConverterUInt32.lower(v))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashBlockHeight_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def value(self, ):
        return FfiConverterUInt32.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashBlockHeight_value,self._pointer,)
        )
    


class FfiConverterTypeZcashBlockHeight:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashBlockHeight):
            raise TypeError("Expected ZcashBlockHeight instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashBlockHeight._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashCommitmentTree(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashCommitmentTree_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def empty(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashCommitmentTree_empty,)
        return cls._make_instance_(pointer)
    

    def append(self, node):
        node = node
        
        rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashCommitmentTree_append,self._pointer,
        FfiConverterTypeZcashSaplingNode.lower(node))
    
    


class FfiConverterTypeZcashCommitmentTree:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashCommitmentTree):
            raise TypeError("Expected ZcashCommitmentTree instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashCommitmentTree._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashDiversifiableFullViewingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashDiversifiableFullViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_bytes,self._pointer,)
        )
    def fvk(self, ):
        return FfiConverterTypeZcashFullViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_fvk,self._pointer,)
        )
    def to_nk(self, scope):
        scope = scope
        
        return FfiConverterTypeZcashNullifierDerivingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_nk,self._pointer,
        FfiConverterTypeZcashScope.lower(scope))
        )
    def to_ivk(self, scope):
        scope = scope
        
        return FfiConverterTypeZcashSaplingIvk.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_ivk,self._pointer,
        FfiConverterTypeZcashScope.lower(scope))
        )
    def to_ovk(self, scope):
        scope = scope
        
        return FfiConverterTypeZcashOutgoingViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_to_ovk,self._pointer,
        FfiConverterTypeZcashScope.lower(scope))
        )
    def address(self, j):
        j = j
        
        return FfiConverterOptionalTypeZcashPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_address,self._pointer,
        FfiConverterTypeZcashDiversifierIndex.lower(j))
        )
    def find_address(self, j):
        j = j
        
        return FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_find_address,self._pointer,
        FfiConverterTypeZcashDiversifierIndex.lower(j))
        )
    def default_address(self, ):
        return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_default_address,self._pointer,)
        )
    def diversified_address(self, diversifier):
        diversifier = diversifier
        
        return FfiConverterOptionalTypeZcashPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_diversified_address,self._pointer,
        FfiConverterTypeZcashDiversifier.lower(diversifier))
        )
    def change_address(self, ):
        return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_change_address,self._pointer,)
        )
    def diversified_change_address(self, diversifier):
        diversifier = diversifier
        
        return FfiConverterOptionalTypeZcashPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_diversified_change_address,self._pointer,
        FfiConverterTypeZcashDiversifier.lower(diversifier))
        )
    def decrypt_diversifier(self, addr):
        addr = addr
        
        return FfiConverterOptionalTypeZcashDiversifierIndexAndScope.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifiableFullViewingKey_decrypt_diversifier,self._pointer,
        FfiConverterTypeZcashPaymentAddress.lower(addr))
        )
    


class FfiConverterTypeZcashDiversifiableFullViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashDiversifiableFullViewingKey):
            raise TypeError("Expected ZcashDiversifiableFullViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashDiversifiableFullViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashDiversifier(object): 
    def __init__(self, bytes):
        bytes = list(int(x) for x in bytes)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashDiversifier_new,
        FfiConverterSequenceUInt8.lower(bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashDiversifier_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifier_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashDiversifier:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashDiversifier):
            raise TypeError("Expected ZcashDiversifier instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashDiversifier._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashDiversifierIndex(object): 
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashDiversifierIndex_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashDiversifierIndex_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_u32(cls, i):
        i = int(i)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashDiversifierIndex_from_u32,
        FfiConverterUInt32.lower(i))
        return cls._make_instance_(pointer)
    @classmethod
    def from_u64(cls, i):
        i = int(i)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashDiversifierIndex_from_u64,
        FfiConverterUInt64.lower(i))
        return cls._make_instance_(pointer)
    

    def increment(self, ):
        rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashDiversifierIndex_increment,self._pointer,)
    
    def to_u32(self, ):
        return FfiConverterUInt32.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashDiversifierIndex_to_u32,self._pointer,)
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashDiversifierIndex_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashDiversifierIndex:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashDiversifierIndex):
            raise TypeError("Expected ZcashDiversifierIndex instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashDiversifierIndex._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashExpandedSpendingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashExpandedSpendingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_spending_key(cls, sk):
        sk = list(int(x) for x in sk)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_from_spending_key,
        FfiConverterSequenceUInt8.lower(sk))
        return cls._make_instance_(pointer)
    @classmethod
    def from_bytes(cls, b):
        b = list(int(x) for x in b)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(b))
        return cls._make_instance_(pointer)
    

    def proof_generation_key(self, ):
        return FfiConverterTypeZcashProofGenerationKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_proof_generation_key,self._pointer,)
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExpandedSpendingKey_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashExpandedSpendingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashExpandedSpendingKey):
            raise TypeError("Expected ZcashExpandedSpendingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashExpandedSpendingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashExtendedFullViewingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashExtendedFullViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    @classmethod
    def decode(cls, params,input):
        params = params
        
        input = input
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_decode,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterString.lower(input))
        return cls._make_instance_(pointer)
    

    def encode(self, params):
        params = params
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_encode,self._pointer,
        FfiConverterTypeZcashConsensusParameters.lower(params))
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_to_bytes,self._pointer,)
        )
    def address(self, j):
        j = j
        
        return FfiConverterOptionalTypeZcashPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_address,self._pointer,
        FfiConverterTypeZcashDiversifierIndex.lower(j))
        )
    def derive_child(self, i):
        i = i
        
        return FfiConverterTypeZcashExtendedFullViewingKey.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_derive_child,self._pointer,
        FfiConverterTypeZcashChildIndex.lower(i))
        )
    def find_address(self, j):
        j = j
        
        return FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_find_address,self._pointer,
        FfiConverterTypeZcashDiversifierIndex.lower(j))
        )
    def default_address(self, ):
        return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_default_address,self._pointer,)
        )
    def derive_internal(self, ):
        return FfiConverterTypeZcashExtendedFullViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_derive_internal,self._pointer,)
        )
    def to_diversifiable_full_viewing_key(self, ):
        return FfiConverterTypeZcashDiversifiableFullViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key,self._pointer,)
        )
    


class FfiConverterTypeZcashExtendedFullViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashExtendedFullViewingKey):
            raise TypeError("Expected ZcashExtendedFullViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashExtendedFullViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashExtendedPrivKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashExtendedPrivKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def random(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedPrivKey_random,)
        return cls._make_instance_(pointer)
    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedPrivKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    @classmethod
    def random_with_seed_size(cls, seed_size):
        seed_size = seed_size
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedPrivKey_random_with_seed_size,
        FfiConverterTypeZcashKeySeed.lower(seed_size))
        return cls._make_instance_(pointer)
    @classmethod
    def with_seed(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedPrivKey_with_seed,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedPrivKey_to_bytes,self._pointer,)
        )
    def derive_private_key(self, key_index):
        key_index = key_index
        
        return FfiConverterTypeZcashExtendedPrivKey.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedPrivKey_derive_private_key,self._pointer,
        FfiConverterTypeZcashKeyIndex.lower(key_index))
        )
    


class FfiConverterTypeZcashExtendedPrivKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashExtendedPrivKey):
            raise TypeError("Expected ZcashExtendedPrivKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashExtendedPrivKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashExtendedSpendingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashExtendedSpendingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def master(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_master,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    @classmethod
    def from_path(cls, master,path):
        master = master
        
        path = list(x for x in path)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_from_path,
        FfiConverterTypeZcashExtendedSpendingKey.lower(master),
        FfiConverterSequenceTypeZcashChildIndex.lower(path))
        return cls._make_instance_(pointer)
    @classmethod
    def decode(cls, params,input):
        params = params
        
        input = input
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_decode,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterString.lower(input))
        return cls._make_instance_(pointer)
    

    def encode(self, params):
        params = params
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_encode,self._pointer,
        FfiConverterTypeZcashConsensusParameters.lower(params))
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_to_bytes,self._pointer,)
        )
    def derive_child(self, index):
        index = index
        
        return FfiConverterTypeZcashExtendedSpendingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_derive_child,self._pointer,
        FfiConverterTypeZcashChildIndex.lower(index))
        )
    def default_address(self, ):
        return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_default_address,self._pointer,)
        )
    def derive_internal(self, ):
        return FfiConverterTypeZcashExtendedSpendingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_derive_internal,self._pointer,)
        )
    def to_diversifiable_full_viewing_key(self, ):
        return FfiConverterTypeZcashDiversifiableFullViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key,self._pointer,)
        )
    


class FfiConverterTypeZcashExtendedSpendingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashExtendedSpendingKey):
            raise TypeError("Expected ZcashExtendedSpendingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashExtendedSpendingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashExternalIvk(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashExternalIvk_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExternalIvk_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    

    def derive_address(self, child_index):
        child_index = int(child_index)
        
        return FfiConverterTypeZcashTransparentAddress.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExternalIvk_derive_address,self._pointer,
        FfiConverterUInt32.lower(child_index))
        )
    def default_address(self, ):
        return FfiConverterTypeZcashTransparentAddressAndIndex.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExternalIvk_default_address,self._pointer,)
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExternalIvk_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashExternalIvk:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashExternalIvk):
            raise TypeError("Expected ZcashExternalIvk instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashExternalIvk._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashExternalOvk(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashExternalOvk_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def as_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExternalOvk_as_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashExternalOvk:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashExternalOvk):
            raise TypeError("Expected ZcashExternalOvk instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashExternalOvk._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashExtractedNoteCommitment(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashExtractedNoteCommitment_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashExtractedNoteCommitment_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashExtractedNoteCommitment_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashExtractedNoteCommitment:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashExtractedNoteCommitment):
            raise TypeError("Expected ZcashExtractedNoteCommitment instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashExtractedNoteCommitment._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashFixedFeeRule(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashFixedFeeRule_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def non_standard(cls, fixed_fee):
        fixed_fee = fixed_fee
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashFixedFeeRule_non_standard,
        FfiConverterTypeZcashAmount.lower(fixed_fee))
        return cls._make_instance_(pointer)
    @classmethod
    def standard(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashFixedFeeRule_standard,)
        return cls._make_instance_(pointer)
    

    def fixed_fee(self, ):
        return FfiConverterTypeZcashAmount.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashFixedFeeRule_fixed_fee,self._pointer,)
        )
    


class FfiConverterTypeZcashFixedFeeRule:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashFixedFeeRule):
            raise TypeError("Expected ZcashFixedFeeRule instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashFixedFeeRule._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashFullViewingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashFullViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashFullViewingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    @classmethod
    def from_expanded_spending_key(cls, expsk):
        expsk = expsk
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashFullViewingKey_from_expanded_spending_key,
        FfiConverterTypeZcashExpandedSpendingKey.lower(expsk))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashFullViewingKey_to_bytes,self._pointer,)
        )
    def vk(self, ):
        return FfiConverterTypeZcashViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashFullViewingKey_vk,self._pointer,)
        )
    def ovk(self, ):
        return FfiConverterTypeZcashOutgoingViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashFullViewingKey_ovk,self._pointer,)
        )
    


class FfiConverterTypeZcashFullViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashFullViewingKey):
            raise TypeError("Expected ZcashFullViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashFullViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashIncrementalWitness(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashIncrementalWitness_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_tree(cls, tree):
        tree = tree
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashIncrementalWitness_from_tree,
        FfiConverterTypeZcashCommitmentTree.lower(tree))
        return cls._make_instance_(pointer)
    

    def append(self, node):
        node = node
        
        rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashIncrementalWitness_append,self._pointer,
        FfiConverterTypeZcashSaplingNode.lower(node))
    
    def path(self, ):
        return FfiConverterOptionalTypeZcashSaplingMerklePath.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashIncrementalWitness_path,self._pointer,)
        )
    


class FfiConverterTypeZcashIncrementalWitness:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashIncrementalWitness):
            raise TypeError("Expected ZcashIncrementalWitness instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashIncrementalWitness._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashInternalIvk(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashInternalIvk_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashInternalIvk_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    

    def default_address(self, ):
        return FfiConverterTypeZcashTransparentAddressAndIndex.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashInternalIvk_default_address,self._pointer,)
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashInternalIvk_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashInternalIvk:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashInternalIvk):
            raise TypeError("Expected ZcashInternalIvk instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashInternalIvk._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashInternalOvk(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashInternalOvk_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def as_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashInternalOvk_as_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashInternalOvk:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashInternalOvk):
            raise TypeError("Expected ZcashInternalOvk instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashInternalOvk._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashJubjubFr(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashJubjubFr_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashJubjubFr_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashJubjubFr_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashJubjubFr:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashJubjubFr):
            raise TypeError("Expected ZcashJubjubFr instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashJubjubFr._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashKeyIndex(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashKeyIndex_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_u32(cls, i):
        i = int(i)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashKeyIndex_from_u32,
        FfiConverterUInt32.lower(i))
        return cls._make_instance_(pointer)
    @classmethod
    def hardened_from_normalize_index(cls, i):
        i = int(i)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashKeyIndex_hardened_from_normalize_index,
        FfiConverterUInt32.lower(i))
        return cls._make_instance_(pointer)
    @classmethod
    def from_index(cls, i):
        i = int(i)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashKeyIndex_from_index,
        FfiConverterUInt32.lower(i))
        return cls._make_instance_(pointer)
    

    def raw_index(self, ):
        return FfiConverterUInt32.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashKeyIndex_raw_index,self._pointer,)
        )
    def normalize_index(self, ):
        return FfiConverterUInt32.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashKeyIndex_normalize_index,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashKeyIndex_is_valid,self._pointer,)
        )
    


class FfiConverterTypeZcashKeyIndex:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashKeyIndex):
            raise TypeError("Expected ZcashKeyIndex instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashKeyIndex._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashLocalTxProver(object): 
    def __init__(self, spend_path,output_path):
        spend_path = spend_path
        
        output_path = output_path
        
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashLocalTxProver_new,
        FfiConverterString.lower(spend_path),
        FfiConverterString.lower(output_path))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashLocalTxProver_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, spend_param_bytes,output_param_bytes):
        spend_param_bytes = list(int(x) for x in spend_param_bytes)
        
        output_param_bytes = list(int(x) for x in output_param_bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashLocalTxProver_from_bytes,
        FfiConverterSequenceUInt8.lower(spend_param_bytes),
        FfiConverterSequenceUInt8.lower(output_param_bytes))
        return cls._make_instance_(pointer)
    @classmethod
    def with_default_location(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashLocalTxProver_with_default_location,)
        return cls._make_instance_(pointer)
    

    


class FfiConverterTypeZcashLocalTxProver:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashLocalTxProver):
            raise TypeError("Expected ZcashLocalTxProver instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashLocalTxProver._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashMemoBytes(object): 
    def __init__(self, data):
        data = list(int(x) for x in data)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashMemoBytes_new,
        FfiConverterSequenceUInt8.lower(data))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashMemoBytes_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def empty(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashMemoBytes_empty,)
        return cls._make_instance_(pointer)
    

    def data(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashMemoBytes_data,self._pointer,)
        )
    


class FfiConverterTypeZcashMemoBytes:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashMemoBytes):
            raise TypeError("Expected ZcashMemoBytes instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashMemoBytes._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashNullifierDerivingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashNullifierDerivingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashNullifierDerivingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashNullifierDerivingKey_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashNullifierDerivingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashNullifierDerivingKey):
            raise TypeError("Expected ZcashNullifierDerivingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashNullifierDerivingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardAction(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardAction_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def nullifier(self, ):
        return FfiConverterTypeZcashOrchardNullifier.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardAction_nullifier,self._pointer,)
        )
    def cmx(self, ):
        return FfiConverterTypeZcashExtractedNoteCommitment.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardAction_cmx,self._pointer,)
        )
    def encrypted_note(self, ):
        return FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardAction_encrypted_note,self._pointer,)
        )
    def cv_net(self, ):
        return FfiConverterTypeZcashOrchardValueCommitment.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardAction_cv_net,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardAction:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardAction):
            raise TypeError("Expected ZcashOrchardAction instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardAction._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardAddress(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardAddress_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_raw_address_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardAddress_from_raw_address_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    

    def diversifier(self, ):
        return FfiConverterTypeZcashOrchardDiversifier.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardAddress_diversifier,self._pointer,)
        )
    def to_raw_address_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardAddress_to_raw_address_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardAddress):
            raise TypeError("Expected ZcashOrchardAddress instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardAddress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardBundle(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardBundle_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def actions(self, ):
        return FfiConverterSequenceTypeZcashOrchardAction.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardBundle_actions,self._pointer,)
        )
    def flags(self, ):
        return FfiConverterTypeZcashOrchardFlags.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardBundle_flags,self._pointer,)
        )
    def value_balance(self, ):
        return FfiConverterTypeZcashAmount.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardBundle_value_balance,self._pointer,)
        )
    def anchor(self, ):
        return FfiConverterTypeZcashAnchor.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardBundle_anchor,self._pointer,)
        )
    def verify_proof(self, key):
        key = key
        
        rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardBundle_verify_proof,self._pointer,
        FfiConverterTypeZcashVerifyingKey.lower(key))
    
    def decrypt_output_with_key(self, action_idx,ivk):
        action_idx = int(action_idx)
        
        ivk = ivk
        
        return FfiConverterTypeZcashOrchardDecryptOutput.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardBundle_decrypt_output_with_key,self._pointer,
        FfiConverterUInt64.lower(action_idx),
        FfiConverterTypeZcashOrchardIncomingViewingKey.lower(ivk))
        )
    def decrypt_output_with_keys(self, ivks):
        ivks = list(x for x in ivks)
        
        return FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardBundle_decrypt_output_with_keys,self._pointer,
        FfiConverterSequenceTypeZcashOrchardIncomingViewingKey.lower(ivks))
        )
    def recover_output_with_ovk(self, action_idx,ovk):
        action_idx = int(action_idx)
        
        ovk = ovk
        
        return FfiConverterTypeZcashOrchardDecryptOutput.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardBundle_recover_output_with_ovk,self._pointer,
        FfiConverterUInt64.lower(action_idx),
        FfiConverterTypeZcashOrchardOutgoingViewingKey.lower(ovk))
        )
    def recover_outputs_with_ovks(self, ovks):
        ovks = list(x for x in ovks)
        
        return FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardBundle_recover_outputs_with_ovks,self._pointer,
        FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey.lower(ovks))
        )
    


class FfiConverterTypeZcashOrchardBundle:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardBundle):
            raise TypeError("Expected ZcashOrchardBundle instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardBundle._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardDiversifier(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardDiversifier_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardDiversifier_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardDiversifier_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardDiversifier:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardDiversifier):
            raise TypeError("Expected ZcashOrchardDiversifier instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardDiversifier._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardDiversifierIndex(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardDiversifierIndex_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, b):
        b = list(int(x) for x in b)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_bytes,
        FfiConverterSequenceUInt8.lower(b))
        return cls._make_instance_(pointer)
    @classmethod
    def from_u32(cls, i):
        i = int(i)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_u32,
        FfiConverterUInt32.lower(i))
        return cls._make_instance_(pointer)
    @classmethod
    def from_u64(cls, i):
        i = int(i)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_from_u64,
        FfiConverterUInt64.lower(i))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardDiversifierIndex_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardDiversifierIndex:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardDiversifierIndex):
            raise TypeError("Expected ZcashOrchardDiversifierIndex instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardDiversifierIndex._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardFlags(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardFlags_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_parts(cls, spends_enabled,outputs_enabled):
        spends_enabled = bool(spends_enabled)
        
        outputs_enabled = bool(outputs_enabled)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashOrchardFlags_from_parts,
        FfiConverterBool.lower(spends_enabled),
        FfiConverterBool.lower(outputs_enabled))
        return cls._make_instance_(pointer)
    @classmethod
    def from_byte(cls, v):
        v = int(v)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardFlags_from_byte,
        FfiConverterUInt8.lower(v))
        return cls._make_instance_(pointer)
    

    def spends_enabled(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFlags_spends_enabled,self._pointer,)
        )
    def outputs_enabled(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFlags_outputs_enabled,self._pointer,)
        )
    def to_byte(self, ):
        return FfiConverterUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFlags_to_byte,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardFlags:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardFlags):
            raise TypeError("Expected ZcashOrchardFlags instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardFlags._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardFullViewingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardFullViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    

    def address_at(self, j,scope):
        j = j
        
        scope = scope
        
        return FfiConverterTypeZcashOrchardAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_address_at,self._pointer,
        FfiConverterTypeZcashOrchardDiversifierIndex.lower(j),
        FfiConverterTypeZcashOrchardScope.lower(scope))
        )
    def address(self, d,scope):
        d = d
        
        scope = scope
        
        return FfiConverterTypeZcashOrchardAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_address,self._pointer,
        FfiConverterTypeZcashOrchardDiversifier.lower(d),
        FfiConverterTypeZcashOrchardScope.lower(scope))
        )
    def scope_for_address(self, address):
        address = address
        
        return FfiConverterOptionalTypeZcashOrchardScope.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_scope_for_address,self._pointer,
        FfiConverterTypeZcashOrchardAddress.lower(address))
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_bytes,self._pointer,)
        )
    def to_ivk(self, scope):
        scope = scope
        
        return FfiConverterTypeZcashOrchardIncomingViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_ivk,self._pointer,
        FfiConverterTypeZcashOrchardScope.lower(scope))
        )
    def to_ovk(self, scope):
        scope = scope
        
        return FfiConverterTypeZcashOrchardOutgoingViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardFullViewingKey_to_ovk,self._pointer,
        FfiConverterTypeZcashOrchardScope.lower(scope))
        )
    


class FfiConverterTypeZcashOrchardFullViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardFullViewingKey):
            raise TypeError("Expected ZcashOrchardFullViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardFullViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardIncomingViewingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardIncomingViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_to_bytes,self._pointer,)
        )
    def diversifier_index(self, addr):
        addr = addr
        
        return FfiConverterOptionalTypeZcashOrchardDiversifierIndex.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_diversifier_index,self._pointer,
        FfiConverterTypeZcashOrchardAddress.lower(addr))
        )
    def address_at(self, j):
        j = j
        
        return FfiConverterTypeZcashOrchardAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_address_at,self._pointer,
        FfiConverterTypeZcashOrchardDiversifierIndex.lower(j))
        )
    def address(self, diversifier):
        diversifier = diversifier
        
        return FfiConverterTypeZcashOrchardAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardIncomingViewingKey_address,self._pointer,
        FfiConverterTypeZcashOrchardDiversifier.lower(diversifier))
        )
    


class FfiConverterTypeZcashOrchardIncomingViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardIncomingViewingKey):
            raise TypeError("Expected ZcashOrchardIncomingViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardIncomingViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardMerkleHash(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardMerkleHash_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    @classmethod
    def from_cmx(cls, cmx):
        cmx = cmx
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_from_cmx,
        FfiConverterTypeZcashExtractedNoteCommitment.lower(cmx))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardMerkleHash_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardMerkleHash:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardMerkleHash):
            raise TypeError("Expected ZcashOrchardMerkleHash instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardMerkleHash._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardMerklePath(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardMerklePath_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_parts(cls, position,auth_path):
        position = int(position)
        
        auth_path = list(x for x in auth_path)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardMerklePath_from_parts,
        FfiConverterUInt32.lower(position),
        FfiConverterSequenceTypeZcashOrchardMerkleHash.lower(auth_path))
        return cls._make_instance_(pointer)
    

    def root(self, cmx):
        cmx = cmx
        
        return FfiConverterTypeZcashAnchor.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardMerklePath_root,self._pointer,
        FfiConverterTypeZcashExtractedNoteCommitment.lower(cmx))
        )
    


class FfiConverterTypeZcashOrchardMerklePath:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardMerklePath):
            raise TypeError("Expected ZcashOrchardMerklePath instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardMerklePath._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardNote(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardNote_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_parts(cls, recipient,value,rho,rseed):
        recipient = recipient
        
        value = value
        
        rho = rho
        
        rseed = rseed
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardNote_from_parts,
        FfiConverterTypeZcashOrchardAddress.lower(recipient),
        FfiConverterTypeZcashOrchardNoteValue.lower(value),
        FfiConverterTypeZcashOrchardNullifier.lower(rho),
        FfiConverterTypeZcashOrchardRandomSeed.lower(rseed))
        return cls._make_instance_(pointer)
    

    def recipient(self, ):
        return FfiConverterTypeZcashOrchardAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardNote_recipient,self._pointer,)
        )
    def value(self, ):
        return FfiConverterTypeZcashOrchardNoteValue.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardNote_value,self._pointer,)
        )
    def commitment(self, ):
        return FfiConverterTypeZcashOrchardNoteCommitment.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardNote_commitment,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardNote:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardNote):
            raise TypeError("Expected ZcashOrchardNote instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardNote._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardNoteCommitment(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardNoteCommitment_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_extracted_note_commitment(self, ):
        return FfiConverterTypeZcashExtractedNoteCommitment.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardNoteCommitment_to_extracted_note_commitment,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardNoteCommitment:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardNoteCommitment):
            raise TypeError("Expected ZcashOrchardNoteCommitment instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardNoteCommitment._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardNoteValue(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardNoteValue_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_raw(cls, value):
        value = int(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashOrchardNoteValue_from_raw,
        FfiConverterUInt64.lower(value))
        return cls._make_instance_(pointer)
    

    def value(self, ):
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardNoteValue_value,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardNoteValue:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardNoteValue):
            raise TypeError("Expected ZcashOrchardNoteValue instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardNoteValue._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardNullifier(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardNullifier_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardNullifier_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardNullifier_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardNullifier:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardNullifier):
            raise TypeError("Expected ZcashOrchardNullifier instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardNullifier._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardOutgoingViewingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardOutgoingViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardOutgoingViewingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardOutgoingViewingKey_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardOutgoingViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardOutgoingViewingKey):
            raise TypeError("Expected ZcashOrchardOutgoingViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardOutgoingViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardRandomSeed(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardRandomSeed_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data,rho):
        data = list(int(x) for x in data)
        
        rho = rho
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardRandomSeed_from_bytes,
        FfiConverterSequenceUInt8.lower(data),
        FfiConverterTypeZcashOrchardNullifier.lower(rho))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardRandomSeed_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardRandomSeed:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardRandomSeed):
            raise TypeError("Expected ZcashOrchardRandomSeed instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardRandomSeed._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardSpendingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardSpendingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    @classmethod
    def from_zip32_seed(cls, seed,coin_type,account):
        seed = list(int(x) for x in seed)
        
        coin_type = int(coin_type)
        
        account = int(account)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_from_zip32_seed,
        FfiConverterSequenceUInt8.lower(seed),
        FfiConverterUInt32.lower(coin_type),
        FfiConverterUInt32.lower(account))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_to_bytes,self._pointer,)
        )
    def to_fvk(self, ):
        return FfiConverterTypeZcashOrchardFullViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardSpendingKey_to_fvk,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardSpendingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardSpendingKey):
            raise TypeError("Expected ZcashOrchardSpendingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardSpendingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardTransactionBuilder(object): 
    def __init__(self, parameters,target_height,expiry_height,anchor,flags):
        parameters = parameters
        
        target_height = target_height
        
        expiry_height = expiry_height
        
        anchor = anchor
        
        flags = flags
        
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_new,
        FfiConverterTypeZcashConsensusParameters.lower(parameters),
        FfiConverterTypeZcashBlockHeight.lower(target_height),
        FfiConverterTypeZcashBlockHeight.lower(expiry_height),
        FfiConverterTypeZcashAnchor.lower(anchor),
        FfiConverterTypeZcashOrchardFlags.lower(flags))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardTransactionBuilder_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add_spend(self, fvk,note,merkle_path):
        fvk = fvk
        
        note = note
        
        merkle_path = merkle_path
        
        rust_call(_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_add_spend,self._pointer,
        FfiConverterTypeZcashOrchardFullViewingKey.lower(fvk),
        FfiConverterTypeZcashOrchardNote.lower(note),
        FfiConverterTypeZcashOrchardMerklePath.lower(merkle_path))
    
    def add_recipient(self, ovk,recipient,value,memo):
        ovk = (None if ovk is None else ovk)
        
        recipient = recipient
        
        value = int(value)
        
        memo = (None if memo is None else list(int(x) for x in memo))
        
        rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_add_recipient,self._pointer,
        FfiConverterOptionalTypeZcashOrchardOutgoingViewingKey.lower(ovk),
        FfiConverterTypeZcashOrchardAddress.lower(recipient),
        FfiConverterUInt64.lower(value),
        FfiConverterOptionalSequenceUInt8.lower(memo))
    
    def build(self, keys,sighash):
        keys = list(x for x in keys)
        
        sighash = list(int(x) for x in sighash)
        
        return FfiConverterTypeZcashTransaction.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOrchardTransactionBuilder_build,self._pointer,
        FfiConverterSequenceTypeZcashOrchardSpendingKey.lower(keys),
        FfiConverterSequenceUInt8.lower(sighash))
        )
    


class FfiConverterTypeZcashOrchardTransactionBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardTransactionBuilder):
            raise TypeError("Expected ZcashOrchardTransactionBuilder instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardTransactionBuilder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOrchardValueCommitment(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOrchardValueCommitment_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOrchardValueCommitment_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOrchardValueCommitment:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOrchardValueCommitment):
            raise TypeError("Expected ZcashOrchardValueCommitment instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOrchardValueCommitment._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOutPoint(object): 
    def __init__(self, hash,n):
        hash = list(int(x) for x in hash)
        
        n = int(n)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOutPoint_new,
        FfiConverterSequenceUInt8.lower(hash),
        FfiConverterUInt32.lower(n))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOutPoint_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    


class FfiConverterTypeZcashOutPoint:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOutPoint):
            raise TypeError("Expected ZcashOutPoint instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOutPoint._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashOutgoingViewingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashOutgoingViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, b):
        b = list(int(x) for x in b)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashOutgoingViewingKey_from_bytes,
        FfiConverterSequenceUInt8.lower(b))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashOutgoingViewingKey_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashOutgoingViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashOutgoingViewingKey):
            raise TypeError("Expected ZcashOutgoingViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashOutgoingViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashPaymentAddress(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashPaymentAddress_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashPaymentAddress_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    @classmethod
    def decode(cls, params,input):
        params = params
        
        input = input
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashPaymentAddress_decode,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterString.lower(input))
        return cls._make_instance_(pointer)
    

    def encode(self, params):
        params = params
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashPaymentAddress_encode,self._pointer,
        FfiConverterTypeZcashConsensusParameters.lower(params))
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashPaymentAddress_to_bytes,self._pointer,)
        )
    def diversifier(self, ):
        return FfiConverterTypeZcashDiversifier.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashPaymentAddress_diversifier,self._pointer,)
        )
    def pk_d(self, ):
        return FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashPaymentAddress_pk_d,self._pointer,)
        )
    def create_note(self, value,rseed):
        value = int(value)
        
        rseed = rseed
        
        return FfiConverterTypeZcashSaplingNote.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashPaymentAddress_create_note,self._pointer,
        FfiConverterUInt64.lower(value),
        FfiConverterTypeZcashRseed.lower(rseed))
        )
    


class FfiConverterTypeZcashPaymentAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashPaymentAddress):
            raise TypeError("Expected ZcashPaymentAddress instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashPaymentAddress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashProofGenerationKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashProofGenerationKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_viewing_key(self, ):
        return FfiConverterTypeZcashViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashProofGenerationKey_to_viewing_key,self._pointer,)
        )
    


class FfiConverterTypeZcashProofGenerationKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashProofGenerationKey):
            raise TypeError("Expected ZcashProofGenerationKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashProofGenerationKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashProvingKey(object): 
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashProvingKey_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashProvingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    


class FfiConverterTypeZcashProvingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashProvingKey):
            raise TypeError("Expected ZcashProvingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashProvingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashRecipientAddress(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashRecipientAddress_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decode(cls, params,address):
        params = params
        
        address = address
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashRecipientAddress_decode,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterString.lower(address))
        return cls._make_instance_(pointer)
    @classmethod
    def shielded(cls, addr):
        addr = addr
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashRecipientAddress_shielded,
        FfiConverterTypeZcashPaymentAddress.lower(addr))
        return cls._make_instance_(pointer)
    @classmethod
    def transparent(cls, addr):
        addr = addr
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashRecipientAddress_transparent,
        FfiConverterTypeZcashTransparentAddress.lower(addr))
        return cls._make_instance_(pointer)
    @classmethod
    def unified(cls, addr):
        addr = addr
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashRecipientAddress_unified,
        FfiConverterTypeZcashUnifiedAddress.lower(addr))
        return cls._make_instance_(pointer)
    

    def encode(self, params):
        params = params
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashRecipientAddress_encode,self._pointer,
        FfiConverterTypeZcashConsensusParameters.lower(params))
        )
    


class FfiConverterTypeZcashRecipientAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashRecipientAddress):
            raise TypeError("Expected ZcashRecipientAddress instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashRecipientAddress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingBundle(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingBundle_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def shielded_spends(self, ):
        return FfiConverterSequenceTypeZcashSaplingSpendDescription.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingBundle_shielded_spends,self._pointer,)
        )
    def shielded_outputs(self, ):
        return FfiConverterSequenceTypeZcashSaplingOutputDescription.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingBundle_shielded_outputs,self._pointer,)
        )
    def value_balance(self, ):
        return FfiConverterTypeZcashAmount.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingBundle_value_balance,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingBundle:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingBundle):
            raise TypeError("Expected ZcashSaplingBundle instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingBundle._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingDiversifiedTransmissionKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingDiversifiedTransmissionKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    


class FfiConverterTypeZcashSaplingDiversifiedTransmissionKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingDiversifiedTransmissionKey):
            raise TypeError("Expected ZcashSaplingDiversifiedTransmissionKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingDiversifiedTransmissionKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingExtractedNoteCommitment(object): 
    def __init__(self, data):
        data = list(int(x) for x in data)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashSaplingExtractedNoteCommitment_new,
        FfiConverterSequenceUInt8.lower(data))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingExtractedNoteCommitment_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingExtractedNoteCommitment_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingExtractedNoteCommitment:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingExtractedNoteCommitment):
            raise TypeError("Expected ZcashSaplingExtractedNoteCommitment instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingExtractedNoteCommitment._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingIvk(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingIvk_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_payment_address(self, diversifier):
        diversifier = diversifier
        
        return FfiConverterOptionalTypeZcashPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingIvk_to_payment_address,self._pointer,
        FfiConverterTypeZcashDiversifier.lower(diversifier))
        )
    def to_repr(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingIvk_to_repr,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingIvk:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingIvk):
            raise TypeError("Expected ZcashSaplingIvk instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingIvk._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingMerklePath(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingMerklePath_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def auth_path(self, ):
        return FfiConverterSequenceTypeZcashAuthPath.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingMerklePath_auth_path,self._pointer,)
        )
    def position(self, ):
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingMerklePath_position,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingMerklePath:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingMerklePath):
            raise TypeError("Expected ZcashSaplingMerklePath instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingMerklePath._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingMetadata(object): 
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashSaplingMetadata_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingMetadata_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def spend_index(self, n):
        n = int(n)
        
        return FfiConverterOptionalUInt64.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingMetadata_spend_index,self._pointer,
        FfiConverterUInt64.lower(n))
        )
    def output_index(self, n):
        n = int(n)
        
        return FfiConverterOptionalUInt64.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingMetadata_output_index,self._pointer,
        FfiConverterUInt64.lower(n))
        )
    


class FfiConverterTypeZcashSaplingMetadata:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingMetadata):
            raise TypeError("Expected ZcashSaplingMetadata instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingMetadata._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingNode(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingNode_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_cmu(cls, cmu):
        cmu = cmu
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashSaplingNode_from_cmu,
        FfiConverterTypeZcashSaplingExtractedNoteCommitment.lower(cmu))
        return cls._make_instance_(pointer)
    

    


class FfiConverterTypeZcashSaplingNode:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingNode):
            raise TypeError("Expected ZcashSaplingNode instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingNode._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingNote(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingNote_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_parts(cls, recipient,value,rseed):
        recipient = recipient
        
        value = value
        
        rseed = rseed
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashSaplingNote_from_parts,
        FfiConverterTypeZcashPaymentAddress.lower(recipient),
        FfiConverterTypeZcashSaplingNoteValue.lower(value),
        FfiConverterTypeZcashRseed.lower(rseed))
        return cls._make_instance_(pointer)
    

    def value(self, ):
        return FfiConverterTypeZcashSaplingNoteValue.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingNote_value,self._pointer,)
        )
    def cmu(self, ):
        return FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingNote_cmu,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingNote:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingNote):
            raise TypeError("Expected ZcashSaplingNote instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingNote._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingNoteValue(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingNoteValue_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_raw(cls, data):
        data = int(data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashSaplingNoteValue_from_raw,
        FfiConverterUInt64.lower(data))
        return cls._make_instance_(pointer)
    

    def inner(self, ):
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingNoteValue_inner,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingNoteValue:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingNoteValue):
            raise TypeError("Expected ZcashSaplingNoteValue instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingNoteValue._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingNullifier(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingNullifier_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingNullifier_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingNullifier:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingNullifier):
            raise TypeError("Expected ZcashSaplingNullifier instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingNullifier._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingOutputDescription(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingOutputDescription_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def cv(self, ):
        return FfiConverterTypeZcashSaplingValueCommitment.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingOutputDescription_cv,self._pointer,)
        )
    def cmu(self, ):
        return FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingOutputDescription_cmu,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingOutputDescription:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingOutputDescription):
            raise TypeError("Expected ZcashSaplingOutputDescription instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingOutputDescription._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingPublicKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingPublicKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashSaplingPublicKey_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingPublicKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingPublicKey):
            raise TypeError("Expected ZcashSaplingPublicKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingPublicKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingSpendDescription(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingSpendDescription_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def cv(self, ):
        return FfiConverterTypeZcashSaplingValueCommitment.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_cv,self._pointer,)
        )
    def anchor(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_anchor,self._pointer,)
        )
    def nullifier(self, ):
        return FfiConverterTypeZcashSaplingNullifier.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_nullifier,self._pointer,)
        )
    def rk(self, ):
        return FfiConverterTypeZcashSaplingPublicKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingSpendDescription_rk,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingSpendDescription:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingSpendDescription):
            raise TypeError("Expected ZcashSaplingSpendDescription instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingSpendDescription._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashSaplingValueCommitment(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashSaplingValueCommitment_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashSaplingValueCommitment_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashSaplingValueCommitment:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashSaplingValueCommitment):
            raise TypeError("Expected ZcashSaplingValueCommitment instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashSaplingValueCommitment._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashScript(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashScript_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashScript_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashScript_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashScript:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashScript):
            raise TypeError("Expected ZcashScript instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashScript._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashTransaction(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashTransaction_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data,consensus_branch_id):
        data = list(int(x) for x in data)
        
        consensus_branch_id = consensus_branch_id
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTransaction_from_bytes,
        FfiConverterSequenceUInt8.lower(data),
        FfiConverterTypeZcashBranchId.lower(consensus_branch_id))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTransaction_to_bytes,self._pointer,)
        )
    def txid(self, ):
        return FfiConverterTypeZcashTxId.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransaction_txid,self._pointer,)
        )
    def version(self, ):
        return FfiConverterTypeZcashTxVersion.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransaction_version,self._pointer,)
        )
    def consensus_branch_id(self, ):
        return FfiConverterTypeZcashBranchId.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransaction_consensus_branch_id,self._pointer,)
        )
    def lock_time(self, ):
        return FfiConverterUInt32.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransaction_lock_time,self._pointer,)
        )
    def expiry_height(self, ):
        return FfiConverterTypeZcashBlockHeight.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransaction_expiry_height,self._pointer,)
        )
    def transparent_bundle(self, ):
        return FfiConverterOptionalTypeZcashTransparentBundle.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransaction_transparent_bundle,self._pointer,)
        )
    def sapling_bundle(self, ):
        return FfiConverterOptionalTypeZcashSaplingBundle.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransaction_sapling_bundle,self._pointer,)
        )
    def orchard_bundle(self, ):
        return FfiConverterOptionalTypeZcashOrchardBundle.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransaction_orchard_bundle,self._pointer,)
        )
    


class FfiConverterTypeZcashTransaction:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashTransaction):
            raise TypeError("Expected ZcashTransaction instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashTransaction._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashTransactionBuilder(object): 
    def __init__(self, parameters,block_height):
        parameters = parameters
        
        block_height = block_height
        
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashTransactionBuilder_new,
        FfiConverterTypeZcashConsensusParameters.lower(parameters),
        FfiConverterTypeZcashBlockHeight.lower(block_height))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashTransactionBuilder_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def add_sapling_spend(self, extsk,diversifier,note,merkle_path):
        extsk = extsk
        
        diversifier = diversifier
        
        note = note
        
        merkle_path = merkle_path
        
        rust_call(_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_sapling_spend,self._pointer,
        FfiConverterTypeZcashExtendedSpendingKey.lower(extsk),
        FfiConverterTypeZcashDiversifier.lower(diversifier),
        FfiConverterTypeZcashSaplingNote.lower(note),
        FfiConverterTypeZcashSaplingMerklePath.lower(merkle_path))
    
    def add_sapling_output(self, ovk,to,value,memo):
        ovk = (None if ovk is None else ovk)
        
        to = to
        
        value = value
        
        memo = memo
        
        rust_call(_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_sapling_output,self._pointer,
        FfiConverterOptionalTypeZcashOutgoingViewingKey.lower(ovk),
        FfiConverterTypeZcashPaymentAddress.lower(to),
        FfiConverterTypeZcashAmount.lower(value),
        FfiConverterTypeZcashMemoBytes.lower(memo))
    
    def add_transparent_input(self, sk,utxo,coin):
        sk = sk
        
        utxo = utxo
        
        coin = coin
        
        rust_call(_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_transparent_input,self._pointer,
        FfiConverterTypeSecpSecretKey.lower(sk),
        FfiConverterTypeZcashOutPoint.lower(utxo),
        FfiConverterTypeZcashTxOut.lower(coin))
    
    def add_transparent_output(self, to,value):
        to = to
        
        value = value
        
        rust_call(_UniFFILib.zcash_e53_ZcashTransactionBuilder_add_transparent_output,self._pointer,
        FfiConverterTypeZcashTransparentAddress.lower(to),
        FfiConverterTypeZcashAmount.lower(value))
    
    def build(self, prover,fee_rule):
        prover = prover
        
        fee_rule = fee_rule
        
        return FfiConverterTypeZcashTransactionAndSaplingMetadata.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTransactionBuilder_build,self._pointer,
        FfiConverterTypeZcashLocalTxProver.lower(prover),
        FfiConverterTypeZcashFeeRules.lower(fee_rule))
        )
    


class FfiConverterTypeZcashTransactionBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashTransactionBuilder):
            raise TypeError("Expected ZcashTransactionBuilder instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashTransactionBuilder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashTransparentAddress(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashTransparentAddress_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_public_key(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTransparentAddress_from_public_key,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    @classmethod
    def from_script(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTransparentAddress_from_script,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    @classmethod
    def decode(cls, params,input):
        params = params
        
        input = input
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTransparentAddress_decode,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterString.lower(input))
        return cls._make_instance_(pointer)
    

    def encode(self, params):
        params = params
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransparentAddress_encode,self._pointer,
        FfiConverterTypeZcashConsensusParameters.lower(params))
        )
    def is_public_key(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransparentAddress_is_public_key,self._pointer,)
        )
    def is_script(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransparentAddress_is_script,self._pointer,)
        )
    def script(self, ):
        return FfiConverterTypeZcashScript.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransparentAddress_script,self._pointer,)
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransparentAddress_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashTransparentAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashTransparentAddress):
            raise TypeError("Expected ZcashTransparentAddress instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashTransparentAddress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashTransparentBundle(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashTransparentBundle_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def is_coinbase(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransparentBundle_is_coinbase,self._pointer,)
        )
    def vin(self, ):
        return FfiConverterSequenceTypeZcashTxIn.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransparentBundle_vin,self._pointer,)
        )
    def vout(self, ):
        return FfiConverterSequenceTypeZcashTxOut.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTransparentBundle_vout,self._pointer,)
        )
    


class FfiConverterTypeZcashTransparentBundle:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashTransparentBundle):
            raise TypeError("Expected ZcashTransparentBundle instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashTransparentBundle._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashTxId(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashTxId_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTxId_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTxId_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashTxId:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashTxId):
            raise TypeError("Expected ZcashTxId instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashTxId._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashTxIn(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashTxIn_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTxIn_to_bytes,self._pointer,)
        )
    


class FfiConverterTypeZcashTxIn:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashTxIn):
            raise TypeError("Expected ZcashTxIn instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashTxIn._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashTxOut(object): 
    def __init__(self, value,script_pubkey):
        value = value
        
        script_pubkey = script_pubkey
        
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashTxOut_new,
        FfiConverterTypeZcashAmount.lower(value),
        FfiConverterTypeZcashScript.lower(script_pubkey))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashTxOut_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def value(self, ):
        return FfiConverterTypeZcashAmount.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxOut_value,self._pointer,)
        )
    def script_pubkey(self, ):
        return FfiConverterTypeZcashScript.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxOut_script_pubkey,self._pointer,)
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTxOut_to_bytes,self._pointer,)
        )
    def recipient_address(self, ):
        return FfiConverterOptionalTypeZcashTransparentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxOut_recipient_address,self._pointer,)
        )
    


class FfiConverterTypeZcashTxOut:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashTxOut):
            raise TypeError("Expected ZcashTxOut instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashTxOut._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashTxVersion(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashTxVersion_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, data):
        data = list(int(x) for x in data)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTxVersion_from_bytes,
        FfiConverterSequenceUInt8.lower(data))
        return cls._make_instance_(pointer)
    @classmethod
    def suggested_for_branch(cls, consensus_branch_id):
        consensus_branch_id = consensus_branch_id
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashTxVersion_suggested_for_branch,
        FfiConverterTypeZcashBranchId.lower(consensus_branch_id))
        return cls._make_instance_(pointer)
    

    def selection(self, ):
        return FfiConverterTypeZcashTxVersionSelection.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxVersion_selection,self._pointer,)
        )
    def header(self, ):
        return FfiConverterUInt32.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxVersion_header,self._pointer,)
        )
    def version_group_id(self, ):
        return FfiConverterUInt32.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxVersion_version_group_id,self._pointer,)
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashTxVersion_to_bytes,self._pointer,)
        )
    def has_sprout(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxVersion_has_sprout,self._pointer,)
        )
    def has_overwinter(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxVersion_has_overwinter,self._pointer,)
        )
    def has_sapling(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxVersion_has_sapling,self._pointer,)
        )
    def has_orchard(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashTxVersion_has_orchard,self._pointer,)
        )
    


class FfiConverterTypeZcashTxVersion:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashTxVersion):
            raise TypeError("Expected ZcashTxVersion instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashTxVersion._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashUnifiedAddress(object): 
    def __init__(self, orchard,sapling,transparent):
        orchard = (None if orchard is None else orchard)
        
        sapling = (None if sapling is None else sapling)
        
        transparent = (None if transparent is None else transparent)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashUnifiedAddress_new,
        FfiConverterOptionalTypeZcashOrchardAddress.lower(orchard),
        FfiConverterOptionalTypeZcashPaymentAddress.lower(sapling),
        FfiConverterOptionalTypeZcashTransparentAddress.lower(transparent))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashUnifiedAddress_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decode(cls, params,address):
        params = params
        
        address = address
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashUnifiedAddress_decode,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterString.lower(address))
        return cls._make_instance_(pointer)
    

    def orchard(self, ):
        return FfiConverterOptionalTypeZcashOrchardAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedAddress_orchard,self._pointer,)
        )
    def sapling(self, ):
        return FfiConverterOptionalTypeZcashPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedAddress_sapling,self._pointer,)
        )
    def transparent(self, ):
        return FfiConverterOptionalTypeZcashTransparentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedAddress_transparent,self._pointer,)
        )
    def encode(self, params):
        params = params
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedAddress_encode,self._pointer,
        FfiConverterTypeZcashConsensusParameters.lower(params))
        )
    


class FfiConverterTypeZcashUnifiedAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashUnifiedAddress):
            raise TypeError("Expected ZcashUnifiedAddress instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashUnifiedAddress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashUnifiedFullViewingKey(object): 
    def __init__(self, transparent,sapling,orchard):
        transparent = (None if transparent is None else transparent)
        
        sapling = (None if sapling is None else sapling)
        
        orchard = (None if orchard is None else orchard)
        
        self._pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_new,
        FfiConverterOptionalTypeZcashAccountPubKey.lower(transparent),
        FfiConverterOptionalTypeZcashDiversifiableFullViewingKey.lower(sapling),
        FfiConverterOptionalTypeZcashOrchardFullViewingKey.lower(orchard))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashUnifiedFullViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decode(cls, params,encoded):
        params = params
        
        encoded = encoded
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_decode,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterString.lower(encoded))
        return cls._make_instance_(pointer)
    

    def encode(self, params):
        params = params
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_encode,self._pointer,
        FfiConverterTypeZcashConsensusParameters.lower(params))
        )
    def transparent(self, ):
        return FfiConverterOptionalTypeZcashAccountPubKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_transparent,self._pointer,)
        )
    def sapling(self, ):
        return FfiConverterOptionalTypeZcashDiversifiableFullViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_sapling,self._pointer,)
        )
    def orchard(self, ):
        return FfiConverterOptionalTypeZcashOrchardFullViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_orchard,self._pointer,)
        )
    def address(self, j):
        j = j
        
        return FfiConverterOptionalTypeZcashUnifiedAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_address,self._pointer,
        FfiConverterTypeZcashDiversifierIndex.lower(j))
        )
    def find_address(self, j):
        j = j
        
        return FfiConverterOptionalTypeZcashUnifiedAddressAndDiversifierIndex.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_find_address,self._pointer,
        FfiConverterTypeZcashDiversifierIndex.lower(j))
        )
    def default_address(self, ):
        return FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedFullViewingKey_default_address,self._pointer,)
        )
    


class FfiConverterTypeZcashUnifiedFullViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashUnifiedFullViewingKey):
            raise TypeError("Expected ZcashUnifiedFullViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashUnifiedFullViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashUnifiedSpendingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashUnifiedSpendingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_seed(cls, params,seed,account_id):
        params = params
        
        seed = list(int(x) for x in seed)
        
        account_id = account_id
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_from_seed,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterSequenceUInt8.lower(seed),
        FfiConverterTypeZcashAccountId.lower(account_id))
        return cls._make_instance_(pointer)
    @classmethod
    def from_bytes(cls, era,encoded):
        era = era
        
        encoded = list(int(x) for x in encoded)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_from_bytes,
        FfiConverterTypeZcashKeysEra.lower(era),
        FfiConverterSequenceUInt8.lower(encoded))
        return cls._make_instance_(pointer)
    

    def to_unified_full_viewing_key(self, ):
        return FfiConverterTypeZcashUnifiedFullViewingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_to_unified_full_viewing_key,self._pointer,)
        )
    def transparent(self, ):
        return FfiConverterTypeZcashAccountPrivKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_transparent,self._pointer,)
        )
    def sapling(self, ):
        return FfiConverterTypeZcashExtendedSpendingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_sapling,self._pointer,)
        )
    def orchard(self, ):
        return FfiConverterTypeZcashOrchardSpendingKey.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_orchard,self._pointer,)
        )
    def to_bytes(self, era):
        era = era
        
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashUnifiedSpendingKey_to_bytes,self._pointer,
        FfiConverterTypeZcashKeysEra.lower(era))
        )
    


class FfiConverterTypeZcashUnifiedSpendingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashUnifiedSpendingKey):
            raise TypeError("Expected ZcashUnifiedSpendingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashUnifiedSpendingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashVerifyingKey(object): 
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.zcash_e53_ZcashVerifyingKey_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashVerifyingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    


class FfiConverterTypeZcashVerifyingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashVerifyingKey):
            raise TypeError("Expected ZcashVerifyingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashVerifyingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashViewingKey(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashViewingKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def ivk(self, ):
        return FfiConverterTypeZcashSaplingIvk.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashViewingKey_ivk,self._pointer,)
        )
    def to_payment_address(self, diversifier):
        diversifier = diversifier
        
        return FfiConverterOptionalTypeZcashPaymentAddress.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashViewingKey_to_payment_address,self._pointer,
        FfiConverterTypeZcashDiversifier.lower(diversifier))
        )
    


class FfiConverterTypeZcashViewingKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashViewingKey):
            raise TypeError("Expected ZcashViewingKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashViewingKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZcashZip317FeeRule(object): 

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zcash_e53_ZcashZip317FeeRule_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def standard(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.zcash_e53_ZcashZip317FeeRule_standard,)
        return cls._make_instance_(pointer)
    @classmethod
    def non_standard(cls, marginal_fee,grace_actions,p2pkh_standard_input_size,p2pkh_standard_output_size):
        marginal_fee = marginal_fee
        
        grace_actions = int(grace_actions)
        
        p2pkh_standard_input_size = int(p2pkh_standard_input_size)
        
        p2pkh_standard_output_size = int(p2pkh_standard_output_size)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_ZcashZip317FeeRule_non_standard,
        FfiConverterTypeZcashAmount.lower(marginal_fee),
        FfiConverterUInt64.lower(grace_actions),
        FfiConverterUInt64.lower(p2pkh_standard_input_size),
        FfiConverterUInt64.lower(p2pkh_standard_output_size))
        return cls._make_instance_(pointer)
    

    def marginal_fee(self, ):
        return FfiConverterTypeZcashAmount.lift(
            rust_call(_UniFFILib.zcash_e53_ZcashZip317FeeRule_marginal_fee,self._pointer,)
        )
    


class FfiConverterTypeZcashZip317FeeRule:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZcashZip317FeeRule):
            raise TypeError("Expected ZcashZip317FeeRule instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZcashZip317FeeRule._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class ZcashAccountId: 

    def __init__(self, id):
        self.id = id

    def __str__(self):
        return "ZcashAccountId(id={})".format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True

class FfiConverterTypeZcashAccountId(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashAccountId(
            id=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value.id, buf)


class ZcashAuthPath: 

    def __init__(self, node, bool):
        self.node = node
        self.bool = bool

    def __str__(self):
        return "ZcashAuthPath(node={}, bool={})".format(self.node, self.bool)

    def __eq__(self, other):
        if self.node != other.node:
            return False
        if self.bool != other.bool:
            return False
        return True

class FfiConverterTypeZcashAuthPath(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashAuthPath(
            node=FfiConverterTypeZcashSaplingNode.read(buf),
            bool=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashSaplingNode.write(value.node, buf)
        FfiConverterBool.write(value.bool, buf)


class ZcashDiversifierIndexAndPaymentAddress: 

    def __init__(self, diversifier_index, address):
        self.diversifier_index = diversifier_index
        self.address = address

    def __str__(self):
        return "ZcashDiversifierIndexAndPaymentAddress(diversifier_index={}, address={})".format(self.diversifier_index, self.address)

    def __eq__(self, other):
        if self.diversifier_index != other.diversifier_index:
            return False
        if self.address != other.address:
            return False
        return True

class FfiConverterTypeZcashDiversifierIndexAndPaymentAddress(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashDiversifierIndexAndPaymentAddress(
            diversifier_index=FfiConverterTypeZcashDiversifierIndex.read(buf),
            address=FfiConverterTypeZcashPaymentAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifier_index, buf)
        FfiConverterTypeZcashPaymentAddress.write(value.address, buf)


class ZcashDiversifierIndexAndScope: 

    def __init__(self, diversifier_index, scope):
        self.diversifier_index = diversifier_index
        self.scope = scope

    def __str__(self):
        return "ZcashDiversifierIndexAndScope(diversifier_index={}, scope={})".format(self.diversifier_index, self.scope)

    def __eq__(self, other):
        if self.diversifier_index != other.diversifier_index:
            return False
        if self.scope != other.scope:
            return False
        return True

class FfiConverterTypeZcashDiversifierIndexAndScope(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashDiversifierIndexAndScope(
            diversifier_index=FfiConverterTypeZcashDiversifierIndex.read(buf),
            scope=FfiConverterTypeZcashScope.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifier_index, buf)
        FfiConverterTypeZcashScope.write(value.scope, buf)


class ZcashInternalOvkExternalOvk: 

    def __init__(self, internal_ovk, external_ovk):
        self.internal_ovk = internal_ovk
        self.external_ovk = external_ovk

    def __str__(self):
        return "ZcashInternalOvkExternalOvk(internal_ovk={}, external_ovk={})".format(self.internal_ovk, self.external_ovk)

    def __eq__(self, other):
        if self.internal_ovk != other.internal_ovk:
            return False
        if self.external_ovk != other.external_ovk:
            return False
        return True

class FfiConverterTypeZcashInternalOvkExternalOvk(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashInternalOvkExternalOvk(
            internal_ovk=FfiConverterTypeZcashInternalOvk.read(buf),
            external_ovk=FfiConverterTypeZcashExternalOvk.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashInternalOvk.write(value.internal_ovk, buf)
        FfiConverterTypeZcashExternalOvk.write(value.external_ovk, buf)


class ZcashOrchardDecryptOutput: 

    def __init__(self, note, address, data):
        self.note = note
        self.address = address
        self.data = data

    def __str__(self):
        return "ZcashOrchardDecryptOutput(note={}, address={}, data={})".format(self.note, self.address, self.data)

    def __eq__(self, other):
        if self.note != other.note:
            return False
        if self.address != other.address:
            return False
        if self.data != other.data:
            return False
        return True

class FfiConverterTypeZcashOrchardDecryptOutput(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashOrchardDecryptOutput(
            note=FfiConverterTypeZcashOrchardNote.read(buf),
            address=FfiConverterTypeZcashOrchardAddress.read(buf),
            data=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashOrchardNote.write(value.note, buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, buf)
        FfiConverterSequenceUInt8.write(value.data, buf)


class ZcashOrchardDecryptOutputForIncomingKeys: 

    def __init__(self, idx, key, note, address, data):
        self.idx = idx
        self.key = key
        self.note = note
        self.address = address
        self.data = data

    def __str__(self):
        return "ZcashOrchardDecryptOutputForIncomingKeys(idx={}, key={}, note={}, address={}, data={})".format(self.idx, self.key, self.note, self.address, self.data)

    def __eq__(self, other):
        if self.idx != other.idx:
            return False
        if self.key != other.key:
            return False
        if self.note != other.note:
            return False
        if self.address != other.address:
            return False
        if self.data != other.data:
            return False
        return True

class FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashOrchardDecryptOutputForIncomingKeys(
            idx=FfiConverterUInt64.read(buf),
            key=FfiConverterTypeZcashOrchardIncomingViewingKey.read(buf),
            note=FfiConverterTypeZcashOrchardNote.read(buf),
            address=FfiConverterTypeZcashOrchardAddress.read(buf),
            data=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.idx, buf)
        FfiConverterTypeZcashOrchardIncomingViewingKey.write(value.key, buf)
        FfiConverterTypeZcashOrchardNote.write(value.note, buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, buf)
        FfiConverterSequenceUInt8.write(value.data, buf)


class ZcashOrchardDecryptOutputForOutgoingKeys: 

    def __init__(self, idx, key, note, address, data):
        self.idx = idx
        self.key = key
        self.note = note
        self.address = address
        self.data = data

    def __str__(self):
        return "ZcashOrchardDecryptOutputForOutgoingKeys(idx={}, key={}, note={}, address={}, data={})".format(self.idx, self.key, self.note, self.address, self.data)

    def __eq__(self, other):
        if self.idx != other.idx:
            return False
        if self.key != other.key:
            return False
        if self.note != other.note:
            return False
        if self.address != other.address:
            return False
        if self.data != other.data:
            return False
        return True

class FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashOrchardDecryptOutputForOutgoingKeys(
            idx=FfiConverterUInt64.read(buf),
            key=FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf),
            note=FfiConverterTypeZcashOrchardNote.read(buf),
            address=FfiConverterTypeZcashOrchardAddress.read(buf),
            data=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.idx, buf)
        FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value.key, buf)
        FfiConverterTypeZcashOrchardNote.write(value.note, buf)
        FfiConverterTypeZcashOrchardAddress.write(value.address, buf)
        FfiConverterSequenceUInt8.write(value.data, buf)


class ZcashOrchardTransmittedNoteCiphertext: 

    def __init__(self, epk_bytes, enc_ciphertext, out_ciphertext):
        self.epk_bytes = epk_bytes
        self.enc_ciphertext = enc_ciphertext
        self.out_ciphertext = out_ciphertext

    def __str__(self):
        return "ZcashOrchardTransmittedNoteCiphertext(epk_bytes={}, enc_ciphertext={}, out_ciphertext={})".format(self.epk_bytes, self.enc_ciphertext, self.out_ciphertext)

    def __eq__(self, other):
        if self.epk_bytes != other.epk_bytes:
            return False
        if self.enc_ciphertext != other.enc_ciphertext:
            return False
        if self.out_ciphertext != other.out_ciphertext:
            return False
        return True

class FfiConverterTypeZcashOrchardTransmittedNoteCiphertext(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashOrchardTransmittedNoteCiphertext(
            epk_bytes=FfiConverterSequenceUInt8.read(buf),
            enc_ciphertext=FfiConverterSequenceUInt8.read(buf),
            out_ciphertext=FfiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.epk_bytes, buf)
        FfiConverterSequenceUInt8.write(value.enc_ciphertext, buf)
        FfiConverterSequenceUInt8.write(value.out_ciphertext, buf)


class ZcashPayment: 

    def __init__(self, recipent_address, amount, memo, label, message, other_params):
        self.recipent_address = recipent_address
        self.amount = amount
        self.memo = memo
        self.label = label
        self.message = message
        self.other_params = other_params

    def __str__(self):
        return "ZcashPayment(recipent_address={}, amount={}, memo={}, label={}, message={}, other_params={})".format(self.recipent_address, self.amount, self.memo, self.label, self.message, self.other_params)

    def __eq__(self, other):
        if self.recipent_address != other.recipent_address:
            return False
        if self.amount != other.amount:
            return False
        if self.memo != other.memo:
            return False
        if self.label != other.label:
            return False
        if self.message != other.message:
            return False
        if self.other_params != other.other_params:
            return False
        return True

class FfiConverterTypeZcashPayment(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashPayment(
            recipent_address=FfiConverterTypeZcashRecipientAddress.read(buf),
            amount=FfiConverterInt64.read(buf),
            memo=FfiConverterOptionalTypeZcashMemoBytes.read(buf),
            label=FfiConverterOptionalString.read(buf),
            message=FfiConverterOptionalString.read(buf),
            other_params=FfiConverterSequenceTypeZcashPaymentParam.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashRecipientAddress.write(value.recipent_address, buf)
        FfiConverterInt64.write(value.amount, buf)
        FfiConverterOptionalTypeZcashMemoBytes.write(value.memo, buf)
        FfiConverterOptionalString.write(value.label, buf)
        FfiConverterOptionalString.write(value.message, buf)
        FfiConverterSequenceTypeZcashPaymentParam.write(value.other_params, buf)


class ZcashPaymentParam: 

    def __init__(self, key, value):
        self.key = key
        self.value = value

    def __str__(self):
        return "ZcashPaymentParam(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class FfiConverterTypeZcashPaymentParam(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashPaymentParam(
            key=FfiConverterString.read(buf),
            value=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.key, buf)
        FfiConverterString.write(value.value, buf)


class ZcashTransactionAndSaplingMetadata: 

    def __init__(self, transaction, sapling_metadata):
        self.transaction = transaction
        self.sapling_metadata = sapling_metadata

    def __str__(self):
        return "ZcashTransactionAndSaplingMetadata(transaction={}, sapling_metadata={})".format(self.transaction, self.sapling_metadata)

    def __eq__(self, other):
        if self.transaction != other.transaction:
            return False
        if self.sapling_metadata != other.sapling_metadata:
            return False
        return True

class FfiConverterTypeZcashTransactionAndSaplingMetadata(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashTransactionAndSaplingMetadata(
            transaction=FfiConverterTypeZcashTransaction.read(buf),
            sapling_metadata=FfiConverterTypeZcashSaplingMetadata.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashTransaction.write(value.transaction, buf)
        FfiConverterTypeZcashSaplingMetadata.write(value.sapling_metadata, buf)


class ZcashTransparentAddressAndIndex: 

    def __init__(self, transparent_address, index):
        self.transparent_address = transparent_address
        self.index = index

    def __str__(self):
        return "ZcashTransparentAddressAndIndex(transparent_address={}, index={})".format(self.transparent_address, self.index)

    def __eq__(self, other):
        if self.transparent_address != other.transparent_address:
            return False
        if self.index != other.index:
            return False
        return True

class FfiConverterTypeZcashTransparentAddressAndIndex(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashTransparentAddressAndIndex(
            transparent_address=FfiConverterTypeZcashTransparentAddress.read(buf),
            index=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashTransparentAddress.write(value.transparent_address, buf)
        FfiConverterUInt32.write(value.index, buf)


class ZcashUnifiedAddressAndDiversifierIndex: 

    def __init__(self, address, diversifier_index):
        self.address = address
        self.diversifier_index = diversifier_index

    def __str__(self):
        return "ZcashUnifiedAddressAndDiversifierIndex(address={}, diversifier_index={})".format(self.address, self.diversifier_index)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.diversifier_index != other.diversifier_index:
            return False
        return True

class FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZcashUnifiedAddressAndDiversifierIndex(
            address=FfiConverterTypeZcashUnifiedAddress.read(buf),
            diversifier_index=FfiConverterTypeZcashDiversifierIndex.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZcashUnifiedAddress.write(value.address, buf)
        FfiConverterTypeZcashDiversifierIndex.write(value.diversifier_index, buf)




class ZcashBranchId(enum.Enum): 
    SPROUT = 1
    
    OVERWINTER = 2
    
    SAPLING = 3
    
    BLOSSOM = 4
    
    HEARTWOOD = 5
    
    CANOPY = 6
    
    NU5 = 7
    
    


class FfiConverterTypeZcashBranchId(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashBranchId.SPROUT
        if variant == 2:
            return ZcashBranchId.OVERWINTER
        if variant == 3:
            return ZcashBranchId.SAPLING
        if variant == 4:
            return ZcashBranchId.BLOSSOM
        if variant == 5:
            return ZcashBranchId.HEARTWOOD
        if variant == 6:
            return ZcashBranchId.CANOPY
        if variant == 7:
            return ZcashBranchId.NU5
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ZcashBranchId.SPROUT:
            buf.writeI32(1)
        if value == ZcashBranchId.OVERWINTER:
            buf.writeI32(2)
        if value == ZcashBranchId.SAPLING:
            buf.writeI32(3)
        if value == ZcashBranchId.BLOSSOM:
            buf.writeI32(4)
        if value == ZcashBranchId.HEARTWOOD:
            buf.writeI32(5)
        if value == ZcashBranchId.CANOPY:
            buf.writeI32(6)
        if value == ZcashBranchId.NU5:
            buf.writeI32(7)




class ZcashChildIndex: 
    def __init__(self):
        raise RuntimeError("ZcashChildIndex cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NON_HARDENED(object):
        def __init__(self,v):
            
            self.v = v
            

        def __str__(self):
            return "ZcashChildIndex.NON_HARDENED(v={})".format(self.v)

        def __eq__(self, other):
            if not other.is_non_hardened():
                return False
            if self.v != other.v:
                return False
            return True
    class HARDENED(object):
        def __init__(self,v):
            
            self.v = v
            

        def __str__(self):
            return "ZcashChildIndex.HARDENED(v={})".format(self.v)

        def __eq__(self, other):
            if not other.is_hardened():
                return False
            if self.v != other.v:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_non_hardened(self):
        return isinstance(self, ZcashChildIndex.NON_HARDENED)
    def is_hardened(self):
        return isinstance(self, ZcashChildIndex.HARDENED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ZcashChildIndex.NON_HARDENED = type("ZcashChildIndex.NON_HARDENED", (ZcashChildIndex.NON_HARDENED, ZcashChildIndex,), {})
ZcashChildIndex.HARDENED = type("ZcashChildIndex.HARDENED", (ZcashChildIndex.HARDENED, ZcashChildIndex,), {})




class FfiConverterTypeZcashChildIndex(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashChildIndex.NON_HARDENED(
                FfiConverterUInt32.read(buf),
            )
        if variant == 2:
            return ZcashChildIndex.HARDENED(
                FfiConverterUInt32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_non_hardened():
            buf.writeI32(1)
            FfiConverterUInt32.write(value.v, buf)
        if value.is_hardened():
            buf.writeI32(2)
            FfiConverterUInt32.write(value.v, buf)




class ZcashConsensusParameters(enum.Enum): 
    MAIN_NETWORK = 1
    
    TEST_NETWORK = 2
    
    


class FfiConverterTypeZcashConsensusParameters(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashConsensusParameters.MAIN_NETWORK
        if variant == 2:
            return ZcashConsensusParameters.TEST_NETWORK
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ZcashConsensusParameters.MAIN_NETWORK:
            buf.writeI32(1)
        if value == ZcashConsensusParameters.TEST_NETWORK:
            buf.writeI32(2)




class ZcashFeeRules: 
    def __init__(self):
        raise RuntimeError("ZcashFeeRules cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FIXED_STANDARD(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ZcashFeeRules.FIXED_STANDARD()".format()

        def __eq__(self, other):
            if not other.is_fixed_standard():
                return False
            return True
    class FIXED_NON_STANDARD(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "ZcashFeeRules.FIXED_NON_STANDARD(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_fixed_non_standard():
                return False
            if self.amount != other.amount:
                return False
            return True
    class ZIP317_STANDARD(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ZcashFeeRules.ZIP317_STANDARD()".format()

        def __eq__(self, other):
            if not other.is_zip317_standard():
                return False
            return True
    class ZIP317_NON_STANDARD(object):
        def __init__(self,marginal_fee, grace_actions, p2pkh_standard_input_size, p2pkh_standard_output_size):
            
            self.marginal_fee = marginal_fee
            self.grace_actions = grace_actions
            self.p2pkh_standard_input_size = p2pkh_standard_input_size
            self.p2pkh_standard_output_size = p2pkh_standard_output_size
            

        def __str__(self):
            return "ZcashFeeRules.ZIP317_NON_STANDARD(marginal_fee={}, grace_actions={}, p2pkh_standard_input_size={}, p2pkh_standard_output_size={})".format(self.marginal_fee, self.grace_actions, self.p2pkh_standard_input_size, self.p2pkh_standard_output_size)

        def __eq__(self, other):
            if not other.is_zip317_non_standard():
                return False
            if self.marginal_fee != other.marginal_fee:
                return False
            if self.grace_actions != other.grace_actions:
                return False
            if self.p2pkh_standard_input_size != other.p2pkh_standard_input_size:
                return False
            if self.p2pkh_standard_output_size != other.p2pkh_standard_output_size:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fixed_standard(self):
        return isinstance(self, ZcashFeeRules.FIXED_STANDARD)
    def is_fixed_non_standard(self):
        return isinstance(self, ZcashFeeRules.FIXED_NON_STANDARD)
    def is_zip317_standard(self):
        return isinstance(self, ZcashFeeRules.ZIP317_STANDARD)
    def is_zip317_non_standard(self):
        return isinstance(self, ZcashFeeRules.ZIP317_NON_STANDARD)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ZcashFeeRules.FIXED_STANDARD = type("ZcashFeeRules.FIXED_STANDARD", (ZcashFeeRules.FIXED_STANDARD, ZcashFeeRules,), {})
ZcashFeeRules.FIXED_NON_STANDARD = type("ZcashFeeRules.FIXED_NON_STANDARD", (ZcashFeeRules.FIXED_NON_STANDARD, ZcashFeeRules,), {})
ZcashFeeRules.ZIP317_STANDARD = type("ZcashFeeRules.ZIP317_STANDARD", (ZcashFeeRules.ZIP317_STANDARD, ZcashFeeRules,), {})
ZcashFeeRules.ZIP317_NON_STANDARD = type("ZcashFeeRules.ZIP317_NON_STANDARD", (ZcashFeeRules.ZIP317_NON_STANDARD, ZcashFeeRules,), {})




class FfiConverterTypeZcashFeeRules(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashFeeRules.FIXED_STANDARD(
            )
        if variant == 2:
            return ZcashFeeRules.FIXED_NON_STANDARD(
                FfiConverterUInt64.read(buf),
            )
        if variant == 3:
            return ZcashFeeRules.ZIP317_STANDARD(
            )
        if variant == 4:
            return ZcashFeeRules.ZIP317_NON_STANDARD(
                FfiConverterUInt64.read(buf),
                FfiConverterUInt64.read(buf),
                FfiConverterUInt64.read(buf),
                FfiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fixed_standard():
            buf.writeI32(1)
        if value.is_fixed_non_standard():
            buf.writeI32(2)
            FfiConverterUInt64.write(value.amount, buf)
        if value.is_zip317_standard():
            buf.writeI32(3)
        if value.is_zip317_non_standard():
            buf.writeI32(4)
            FfiConverterUInt64.write(value.marginal_fee, buf)
            FfiConverterUInt64.write(value.grace_actions, buf)
            FfiConverterUInt64.write(value.p2pkh_standard_input_size, buf)
            FfiConverterUInt64.write(value.p2pkh_standard_output_size, buf)




class ZcashKeySeed(enum.Enum): 
    S128 = 1
    
    S256 = 2
    
    S512 = 3
    
    


class FfiConverterTypeZcashKeySeed(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashKeySeed.S128
        if variant == 2:
            return ZcashKeySeed.S256
        if variant == 3:
            return ZcashKeySeed.S512
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ZcashKeySeed.S128:
            buf.writeI32(1)
        if value == ZcashKeySeed.S256:
            buf.writeI32(2)
        if value == ZcashKeySeed.S512:
            buf.writeI32(3)




class ZcashKeysEra(enum.Enum): 
    ORCHARD = 1
    
    


class FfiConverterTypeZcashKeysEra(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashKeysEra.ORCHARD
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ZcashKeysEra.ORCHARD:
            buf.writeI32(1)




class ZcashOrchardScope(enum.Enum): 
    EXTERNAL = 1
    
    INTERNAL = 2
    
    


class FfiConverterTypeZcashOrchardScope(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashOrchardScope.EXTERNAL
        if variant == 2:
            return ZcashOrchardScope.INTERNAL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ZcashOrchardScope.EXTERNAL:
            buf.writeI32(1)
        if value == ZcashOrchardScope.INTERNAL:
            buf.writeI32(2)




class ZcashRseed: 
    def __init__(self):
        raise RuntimeError("ZcashRseed cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BEFORE_ZIP212(object):
        def __init__(self,fr_data):
            
            self.fr_data = fr_data
            

        def __str__(self):
            return "ZcashRseed.BEFORE_ZIP212(fr_data={})".format(self.fr_data)

        def __eq__(self, other):
            if not other.is_before_zip212():
                return False
            if self.fr_data != other.fr_data:
                return False
            return True
    class AFTER_ZIP212(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "ZcashRseed.AFTER_ZIP212(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_after_zip212():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_before_zip212(self):
        return isinstance(self, ZcashRseed.BEFORE_ZIP212)
    def is_after_zip212(self):
        return isinstance(self, ZcashRseed.AFTER_ZIP212)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ZcashRseed.BEFORE_ZIP212 = type("ZcashRseed.BEFORE_ZIP212", (ZcashRseed.BEFORE_ZIP212, ZcashRseed,), {})
ZcashRseed.AFTER_ZIP212 = type("ZcashRseed.AFTER_ZIP212", (ZcashRseed.AFTER_ZIP212, ZcashRseed,), {})




class FfiConverterTypeZcashRseed(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashRseed.BEFORE_ZIP212(
                FfiConverterSequenceUInt8.read(buf),
            )
        if variant == 2:
            return ZcashRseed.AFTER_ZIP212(
                FfiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_before_zip212():
            buf.writeI32(1)
            FfiConverterSequenceUInt8.write(value.fr_data, buf)
        if value.is_after_zip212():
            buf.writeI32(2)
            FfiConverterSequenceUInt8.write(value.data, buf)




class ZcashScope(enum.Enum): 
    EXTERNAL = 1
    
    INTERNAL = 2
    
    


class FfiConverterTypeZcashScope(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashScope.EXTERNAL
        if variant == 2:
            return ZcashScope.INTERNAL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ZcashScope.EXTERNAL:
            buf.writeI32(1)
        if value == ZcashScope.INTERNAL:
            buf.writeI32(2)




class ZcashTxVersionSelection: 
    def __init__(self):
        raise RuntimeError("ZcashTxVersionSelection cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SPROUT(object):
        def __init__(self,v):
            
            self.v = v
            

        def __str__(self):
            return "ZcashTxVersionSelection.SPROUT(v={})".format(self.v)

        def __eq__(self, other):
            if not other.is_sprout():
                return False
            if self.v != other.v:
                return False
            return True
    class OVERWINTER(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ZcashTxVersionSelection.OVERWINTER()".format()

        def __eq__(self, other):
            if not other.is_overwinter():
                return False
            return True
    class SAPLING(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ZcashTxVersionSelection.SAPLING()".format()

        def __eq__(self, other):
            if not other.is_sapling():
                return False
            return True
    class ZIP225(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ZcashTxVersionSelection.ZIP225()".format()

        def __eq__(self, other):
            if not other.is_zip225():
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_sprout(self):
        return isinstance(self, ZcashTxVersionSelection.SPROUT)
    def is_overwinter(self):
        return isinstance(self, ZcashTxVersionSelection.OVERWINTER)
    def is_sapling(self):
        return isinstance(self, ZcashTxVersionSelection.SAPLING)
    def is_zip225(self):
        return isinstance(self, ZcashTxVersionSelection.ZIP225)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ZcashTxVersionSelection.SPROUT = type("ZcashTxVersionSelection.SPROUT", (ZcashTxVersionSelection.SPROUT, ZcashTxVersionSelection,), {})
ZcashTxVersionSelection.OVERWINTER = type("ZcashTxVersionSelection.OVERWINTER", (ZcashTxVersionSelection.OVERWINTER, ZcashTxVersionSelection,), {})
ZcashTxVersionSelection.SAPLING = type("ZcashTxVersionSelection.SAPLING", (ZcashTxVersionSelection.SAPLING, ZcashTxVersionSelection,), {})
ZcashTxVersionSelection.ZIP225 = type("ZcashTxVersionSelection.ZIP225", (ZcashTxVersionSelection.ZIP225, ZcashTxVersionSelection,), {})




class FfiConverterTypeZcashTxVersionSelection(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashTxVersionSelection.SPROUT(
                FfiConverterUInt32.read(buf),
            )
        if variant == 2:
            return ZcashTxVersionSelection.OVERWINTER(
            )
        if variant == 3:
            return ZcashTxVersionSelection.SAPLING(
            )
        if variant == 4:
            return ZcashTxVersionSelection.ZIP225(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_sprout():
            buf.writeI32(1)
            FfiConverterUInt32.write(value.v, buf)
        if value.is_overwinter():
            buf.writeI32(2)
        if value.is_sapling():
            buf.writeI32(3)
        if value.is_zip225():
            buf.writeI32(4)



# ZcashError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class ZcashError(Exception):
        pass
    
    class HdWalletError(ZcashError):
        def __str__(self):
            return "ZcashError.HdWalletError({})".format(repr(super().__str__()))

    ZcashError.HdWalletError = HdWalletError
    class DecodingError(ZcashError):
        def __str__(self):
            return "ZcashError.DecodingError({})".format(repr(super().__str__()))

    ZcashError.DecodingError = DecodingError
    class DerivationError(ZcashError):
        def __str__(self):
            return "ZcashError.DerivationError({})".format(repr(super().__str__()))

    ZcashError.DerivationError = DerivationError
    class InvalidAsk(ZcashError):
        def __str__(self):
            return "ZcashError.InvalidAsk({})".format(repr(super().__str__()))

    ZcashError.InvalidAsk = InvalidAsk
    class InvalidNsk(ZcashError):
        def __str__(self):
            return "ZcashError.InvalidNsk({})".format(repr(super().__str__()))

    ZcashError.InvalidNsk = InvalidNsk
    class Message(ZcashError):
        def __str__(self):
            return "ZcashError.Message({})".format(repr(super().__str__()))

    ZcashError.Message = Message
    class ArrayLengthMismatch(ZcashError):
        def __str__(self):
            return "ZcashError.ArrayLengthMismatch({})".format(repr(super().__str__()))

    ZcashError.ArrayLengthMismatch = ArrayLengthMismatch
    class ValueOutOfRange(ZcashError):
        def __str__(self):
            return "ZcashError.ValueOutOfRange({})".format(repr(super().__str__()))

    ZcashError.ValueOutOfRange = ValueOutOfRange
    class Secp256k1Error(ZcashError):
        def __str__(self):
            return "ZcashError.Secp256k1Error({})".format(repr(super().__str__()))

    ZcashError.Secp256k1Error = Secp256k1Error
    class Bech32DecodeError(ZcashError):
        def __str__(self):
            return "ZcashError.Bech32DecodeError({})".format(repr(super().__str__()))

    ZcashError.Bech32DecodeError = Bech32DecodeError
    class Bs58Error(ZcashError):
        def __str__(self):
            return "ZcashError.Bs58Error({})".format(repr(super().__str__()))

    ZcashError.Bs58Error = Bs58Error
    class BuilderError(ZcashError):
        def __str__(self):
            return "ZcashError.BuilderError({})".format(repr(super().__str__()))

    ZcashError.BuilderError = BuilderError
    class TransparentBuilderError(ZcashError):
        def __str__(self):
            return "ZcashError.TransparentBuilderError({})".format(repr(super().__str__()))

    ZcashError.TransparentBuilderError = TransparentBuilderError
    class SaplingBuilderError(ZcashError):
        def __str__(self):
            return "ZcashError.SaplingBuilderError({})".format(repr(super().__str__()))

    ZcashError.SaplingBuilderError = SaplingBuilderError
    class OrchardBuilderError(ZcashError):
        def __str__(self):
            return "ZcashError.OrchardBuilderError({})".format(repr(super().__str__()))

    ZcashError.OrchardBuilderError = OrchardBuilderError
    class InsufficientFundsError(ZcashError):
        def __str__(self):
            return "ZcashError.InsufficientFundsError({})".format(repr(super().__str__()))

    ZcashError.InsufficientFundsError = InsufficientFundsError
    class ChangeRequiredError(ZcashError):
        def __str__(self):
            return "ZcashError.ChangeRequiredError({})".format(repr(super().__str__()))

    ZcashError.ChangeRequiredError = ChangeRequiredError
    class BalanceError(ZcashError):
        def __str__(self):
            return "ZcashError.BalanceError({})".format(repr(super().__str__()))

    ZcashError.BalanceError = BalanceError
    class IoError(ZcashError):
        def __str__(self):
            return "ZcashError.IoError({})".format(repr(super().__str__()))

    ZcashError.IoError = IoError
    class Unknown(ZcashError):
        def __str__(self):
            return "ZcashError.Unknown({})".format(repr(super().__str__()))

    ZcashError.Unknown = Unknown
ZcashError = UniFFIExceptionTmpNamespace.ZcashError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeZcashError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZcashError.HdWalletError(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ZcashError.DecodingError(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return ZcashError.DerivationError(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return ZcashError.InvalidAsk(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return ZcashError.InvalidNsk(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return ZcashError.Message(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return ZcashError.ArrayLengthMismatch(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return ZcashError.ValueOutOfRange(
                FfiConverterString.read(buf),
            )
        if variant == 9:
            return ZcashError.Secp256k1Error(
                FfiConverterString.read(buf),
            )
        if variant == 10:
            return ZcashError.Bech32DecodeError(
                FfiConverterString.read(buf),
            )
        if variant == 11:
            return ZcashError.Bs58Error(
                FfiConverterString.read(buf),
            )
        if variant == 12:
            return ZcashError.BuilderError(
                FfiConverterString.read(buf),
            )
        if variant == 13:
            return ZcashError.TransparentBuilderError(
                FfiConverterString.read(buf),
            )
        if variant == 14:
            return ZcashError.SaplingBuilderError(
                FfiConverterString.read(buf),
            )
        if variant == 15:
            return ZcashError.OrchardBuilderError(
                FfiConverterString.read(buf),
            )
        if variant == 16:
            return ZcashError.InsufficientFundsError(
                FfiConverterString.read(buf),
            )
        if variant == 17:
            return ZcashError.ChangeRequiredError(
                FfiConverterString.read(buf),
            )
        if variant == 18:
            return ZcashError.BalanceError(
                FfiConverterString.read(buf),
            )
        if variant == 19:
            return ZcashError.IoError(
                FfiConverterString.read(buf),
            )
        if variant == 20:
            return ZcashError.Unknown(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, ZcashError.HdWalletError):
            buf.writeI32(1)
        if isinstance(value, ZcashError.DecodingError):
            buf.writeI32(2)
        if isinstance(value, ZcashError.DerivationError):
            buf.writeI32(3)
        if isinstance(value, ZcashError.InvalidAsk):
            buf.writeI32(4)
        if isinstance(value, ZcashError.InvalidNsk):
            buf.writeI32(5)
        if isinstance(value, ZcashError.Message):
            buf.writeI32(6)
        if isinstance(value, ZcashError.ArrayLengthMismatch):
            buf.writeI32(7)
        if isinstance(value, ZcashError.ValueOutOfRange):
            buf.writeI32(8)
        if isinstance(value, ZcashError.Secp256k1Error):
            buf.writeI32(9)
        if isinstance(value, ZcashError.Bech32DecodeError):
            buf.writeI32(10)
        if isinstance(value, ZcashError.Bs58Error):
            buf.writeI32(11)
        if isinstance(value, ZcashError.BuilderError):
            buf.writeI32(12)
        if isinstance(value, ZcashError.TransparentBuilderError):
            buf.writeI32(13)
        if isinstance(value, ZcashError.SaplingBuilderError):
            buf.writeI32(14)
        if isinstance(value, ZcashError.OrchardBuilderError):
            buf.writeI32(15)
        if isinstance(value, ZcashError.InsufficientFundsError):
            buf.writeI32(16)
        if isinstance(value, ZcashError.ChangeRequiredError):
            buf.writeI32(17)
        if isinstance(value, ZcashError.BalanceError):
            buf.writeI32(18)
        if isinstance(value, ZcashError.IoError):
            buf.writeI32(19)
        if isinstance(value, ZcashError.Unknown):
            buf.writeI32(20)



class FfiConverterOptionalUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashAccountPubKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashAccountPubKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashAccountPubKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashDiversifiableFullViewingKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashDiversifiableFullViewingKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashDiversifiableFullViewingKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashMemoBytes(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashMemoBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashMemoBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashOrchardAddress(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashOrchardAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashOrchardAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashOrchardBundle(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashOrchardBundle.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashOrchardBundle.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashOrchardDiversifierIndex(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashOrchardDiversifierIndex.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashOrchardDiversifierIndex.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashOrchardFullViewingKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashOrchardFullViewingKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashOrchardFullViewingKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashOrchardOutgoingViewingKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashOutgoingViewingKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashOutgoingViewingKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashOutgoingViewingKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashPaymentAddress(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashPaymentAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashPaymentAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashSaplingBundle(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashSaplingBundle.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashSaplingBundle.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashSaplingMerklePath(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashSaplingMerklePath.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashSaplingMerklePath.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashTransparentAddress(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashTransparentAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashTransparentAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashTransparentBundle(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashTransparentBundle.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashTransparentBundle.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashUnifiedAddress(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashUnifiedAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashUnifiedAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashDiversifierIndexAndScope(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashDiversifierIndexAndScope.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashDiversifierIndexAndScope.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashUnifiedAddressAndDiversifierIndex(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZcashOrchardScope(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZcashOrchardScope.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZcashOrchardScope.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceUInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt32.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt32.read(buf) for i in range(count)
        ]



class FfiConverterSequenceUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt64.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashOrchardAction(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashOrchardAction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashOrchardAction.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashOrchardIncomingViewingKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashOrchardIncomingViewingKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashOrchardIncomingViewingKey.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashOrchardMerkleHash(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashOrchardMerkleHash.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashOrchardMerkleHash.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashOrchardOutgoingViewingKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashOrchardSpendingKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashOrchardSpendingKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashOrchardSpendingKey.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashSaplingOutputDescription(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashSaplingOutputDescription.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashSaplingOutputDescription.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashSaplingSpendDescription(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashSaplingSpendDescription.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashSaplingSpendDescription.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashTxIn(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashTxIn.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashTxIn.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashTxOut(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashTxOut.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashTxOut.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashAuthPath(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashAuthPath.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashAuthPath.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashPaymentParam(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashPaymentParam.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashPaymentParam.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeZcashChildIndex(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeZcashChildIndex.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeZcashChildIndex.read(buf) for i in range(count)
        ]

def decode_extended_full_viewing_key(hrp,s):
    hrp = hrp
    
    s = s
    
    return FfiConverterTypeZcashExtendedFullViewingKey.lift(rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_decode_extended_full_viewing_key,
        FfiConverterString.lower(hrp),
        FfiConverterString.lower(s)))



def decode_extended_spending_key(hrp,s):
    hrp = hrp
    
    s = s
    
    return FfiConverterTypeZcashExtendedSpendingKey.lift(rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_decode_extended_spending_key,
        FfiConverterString.lower(hrp),
        FfiConverterString.lower(s)))



def decode_payment_address(hrp,s):
    hrp = hrp
    
    s = s
    
    return FfiConverterTypeZcashPaymentAddress.lift(rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_decode_payment_address,
        FfiConverterString.lower(hrp),
        FfiConverterString.lower(s)))



def decode_transparent_address(pubkey_version,script_version,s):
    pubkey_version = list(int(x) for x in pubkey_version)
    
    script_version = list(int(x) for x in script_version)
    
    s = s
    
    return FfiConverterTypeZcashTransparentAddress.lift(rust_call_with_error(FfiConverterTypeZcashError,_UniFFILib.zcash_e53_decode_transparent_address,
        FfiConverterSequenceUInt8.lower(pubkey_version),
        FfiConverterSequenceUInt8.lower(script_version),
        FfiConverterString.lower(s)))



def encode_extended_full_viewing_key(hrp,extfvk):
    hrp = hrp
    
    extfvk = extfvk
    
    return FfiConverterString.lift(rust_call(_UniFFILib.zcash_e53_encode_extended_full_viewing_key,
        FfiConverterString.lower(hrp),
        FfiConverterTypeZcashExtendedFullViewingKey.lower(extfvk)))



def encode_extended_spending_key(hrp,extsk):
    hrp = hrp
    
    extsk = extsk
    
    return FfiConverterString.lift(rust_call(_UniFFILib.zcash_e53_encode_extended_spending_key,
        FfiConverterString.lower(hrp),
        FfiConverterTypeZcashExtendedSpendingKey.lower(extsk)))



def encode_payment_address(hrp,addr):
    hrp = hrp
    
    addr = addr
    
    return FfiConverterString.lift(rust_call(_UniFFILib.zcash_e53_encode_payment_address,
        FfiConverterString.lower(hrp),
        FfiConverterTypeZcashPaymentAddress.lower(addr)))



def encode_payment_address_p(params,addr):
    params = params
    
    addr = addr
    
    return FfiConverterString.lift(rust_call(_UniFFILib.zcash_e53_encode_payment_address_p,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterTypeZcashPaymentAddress.lower(addr)))



def encode_transparent_address(pubkey_version,script_version,addr):
    pubkey_version = list(int(x) for x in pubkey_version)
    
    script_version = list(int(x) for x in script_version)
    
    addr = addr
    
    return FfiConverterString.lift(rust_call(_UniFFILib.zcash_e53_encode_transparent_address,
        FfiConverterSequenceUInt8.lower(pubkey_version),
        FfiConverterSequenceUInt8.lower(script_version),
        FfiConverterTypeZcashTransparentAddress.lower(addr)))



def encode_transparent_address_p(params,addr):
    params = params
    
    addr = addr
    
    return FfiConverterString.lift(rust_call(_UniFFILib.zcash_e53_encode_transparent_address_p,
        FfiConverterTypeZcashConsensusParameters.lower(params),
        FfiConverterTypeZcashTransparentAddress.lower(addr)))



__all__ = [
    "InternalError",
    "ZcashBranchId",
    "ZcashChildIndex",
    "ZcashConsensusParameters",
    "ZcashFeeRules",
    "ZcashKeySeed",
    "ZcashKeysEra",
    "ZcashOrchardScope",
    "ZcashRseed",
    "ZcashScope",
    "ZcashTxVersionSelection",
    "ZcashAccountId",
    "ZcashAuthPath",
    "ZcashDiversifierIndexAndPaymentAddress",
    "ZcashDiversifierIndexAndScope",
    "ZcashInternalOvkExternalOvk",
    "ZcashOrchardDecryptOutput",
    "ZcashOrchardDecryptOutputForIncomingKeys",
    "ZcashOrchardDecryptOutputForOutgoingKeys",
    "ZcashOrchardTransmittedNoteCiphertext",
    "ZcashPayment",
    "ZcashPaymentParam",
    "ZcashTransactionAndSaplingMetadata",
    "ZcashTransparentAddressAndIndex",
    "ZcashUnifiedAddressAndDiversifierIndex",
    "decode_extended_full_viewing_key",
    "decode_extended_spending_key",
    "decode_payment_address",
    "decode_transparent_address",
    "encode_extended_full_viewing_key",
    "encode_extended_spending_key",
    "encode_payment_address",
    "encode_payment_address_p",
    "encode_transparent_address",
    "encode_transparent_address_p",
    "ZcashRecipientAddress",
    "ZcashUnifiedAddress",
    "ZcashUnifiedFullViewingKey",
    "ZcashUnifiedSpendingKey",
    "ZcashOrchardNote",
    "ZcashOrchardNullifier",
    "ZcashOrchardRandomSeed",
    "ZcashOrchardNoteCommitment",
    "ZcashExtractedNoteCommitment",
    "ZcashOrchardAddress",
    "ZcashVerifyingKey",
    "ZcashProvingKey",
    "ZcashOrchardBundle",
    "ZcashOrchardFlags",
    "ZcashOrchardNoteValue",
    "ZcashOrchardValueCommitment",
    "ZcashOrchardAction",
    "ZcashOrchardFullViewingKey",
    "ZcashOrchardSpendingKey",
    "ZcashAnchor",
    "ZcashOrchardIncomingViewingKey",
    "ZcashOrchardDiversifier",
    "ZcashOrchardOutgoingViewingKey",
    "ZcashOrchardMerklePath",
    "ZcashOrchardMerkleHash",
    "ZcashOrchardDiversifierIndex",
    "ZcashExtendedPrivKey",
    "ZcashKeyIndex",
    "ZcashZip317FeeRule",
    "ZcashFixedFeeRule",
    "ZcashTransparentBundle",
    "ZcashTxOut",
    "ZcashTxIn",
    "ZcashTransactionBuilder",
    "ZcashTransaction",
    "ZcashTxId",
    "ZcashOrchardTransactionBuilder",
    "ZcashTxVersion",
    "ZcashOutPoint",
    "ZcashAmount",
    "ZcashSaplingSpendDescription",
    "ZcashSaplingBundle",
    "ZcashSaplingOutputDescription",
    "ZcashSaplingMetadata",
    "ZcashBlockHeight",
    "ZcashCommitmentTree",
    "ZcashSaplingMerklePath",
    "ZcashIncrementalWitness",
    "ZcashTransparentAddress",
    "ZcashExternalIvk",
    "ZcashInternalIvk",
    "ZcashExternalOvk",
    "ZcashInternalOvk",
    "ZcashAccountPubKey",
    "ZcashAccountPrivKey",
    "ZcashScript",
    "ZcashSaplingValueCommitment",
    "ZcashSaplingNote",
    "ZcashSaplingNoteValue",
    "ZcashSaplingNullifier",
    "ZcashSaplingExtractedNoteCommitment",
    "ZcashPaymentAddress",
    "ZcashSaplingIvk",
    "ZcashDiversifier",
    "ZcashFullViewingKey",
    "ZcashNullifierDerivingKey",
    "ZcashOutgoingViewingKey",
    "ZcashExpandedSpendingKey",
    "ZcashProofGenerationKey",
    "ZcashDiversifiableFullViewingKey",
    "ZcashSaplingDiversifiedTransmissionKey",
    "ZcashViewingKey",
    "ZcashExtendedFullViewingKey",
    "ZcashSaplingPublicKey",
    "ZcashSaplingNode",
    "ZcashExtendedSpendingKey",
    "ZcashDiversifierIndex",
    "ZcashMemoBytes",
    "ZcashLocalTxProver",
    "SecpSecretKey",
    "ZcashJubjubFr",
    "TestSupport",
    "ZcashError",
]

