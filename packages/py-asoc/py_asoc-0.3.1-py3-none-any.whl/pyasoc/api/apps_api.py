"""
    HCL AppScan on Cloud (v2)

    This API allows you to interact with the service. The API allows you to perform many of the operations available in the UI and more.</br>For authentication, use the relevant APIs in the Account section. A successful authentication response includes a bearer token for use in subsequent API calls. Pasting this token in the 'Access token' field above will automatically add the authorization header to any API call that requires a valid session.

    OpenAPI spec version: v2

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import re  # noqa: F401

from pyasoc import api

# python 2 and python 3 compatibility library
from pyasoc.api_client import ApiClient
from pyasoc.models import (
    CommonModelsASMModelsApplicationCreateModel,
    CommonModelsASMModelsApplicationModel,
)


class AppsApi:
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def apps_attach_policy_by_id_and_policyid(self, id, policy_id, parameters, **kwargs):
        """Associate a policy with an application or update association parameters

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_attach_policy_by_id_and_policyid(id, policy_id, parameters, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param str policy_id: Policy ID (required)
        :param list[NameValuePair] parameters: Policy parameters (required)
        :return: PolicyAssociation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_attach_policy_by_id_and_policyid_with_http_info(
                id, policy_id, parameters, **kwargs
            )
        else:
            (data) = self.apps_attach_policy_by_id_and_policyid_with_http_info(
                id, policy_id, parameters, **kwargs
            )
            return data

    def apps_attach_policy_by_id_and_policyid_with_http_info(
        self, id, policy_id, parameters, **kwargs
    ):
        """Associate a policy with an application or update association parameters

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_attach_policy_by_id_and_policyid_with_http_info(id, policy_id, parameters, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param str policy_id: Policy ID (required)
        :param list[NameValuePair] parameters: Policy parameters (required)
        :return: PolicyAssociation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "policy_id", "parameters"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apps_attach_policy_by_id_and_policyid" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_attach_policy_by_id_and_policyid`"
            )
        # verify the required parameter 'policy_id' is set
        if self.api_client.client_side_validation and (
            "policy_id" not in params or params["policy_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `policy_id` when calling `apps_attach_policy_by_id_and_policyid`"
            )
        # verify the required parameter 'parameters' is set
        if self.api_client.client_side_validation and (
            "parameters" not in params or params["parameters"] is None
        ):
            raise ValueError(
                "Missing the required parameter `parameters` when calling `apps_attach_policy_by_id_and_policyid`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]
        if "policy_id" in params:
            path_params["policyId"] = params["policy_id"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "parameters" in params:
            body_params = params["parameters"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(
            ["application/json", "text/json", "application/x-www-form-urlencoded"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/v2/Apps/{id}/Policy/{policyId}",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PolicyAssociation",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_correlation_groups_as_page_by_id(self, id, **kwargs):
        """apps_correlation_groups_as_page_by_id

        OData V3 compliant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_correlation_groups_as_page_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str apply_policies:
        :param list[str] select_policy_ids:
        :param str locale:
        :param int top: The max number of records. (Up to 5000)
        :param int skip: The number of records to skip.
        :param str filter: A function that must evaluate to true for a record to be returned. (e.g. Name eq 'sam' or Name eq 'dan'). To filter an Id Property, open the model and see if its type is \"string\" or \"string($uuid)\". - For string no change is needed. - For \"string($uuid)\" add \"Guid\" immediately before the string (e.g. Id eq Guid'00000000-0000-0000-0000-000000000000')
        :param str select: Specifies a subset of properties to return.
        :param str orderby: Determines what values are used to order a collection of records. (e.g. Name,Id)
        :param str expand: Specifies the related resources to be included in line with retrieved resources.
        :param str inlinecount: Specifies that the response to the request MUST include the count of the number of entities in the collection of entities.
        :return: SystemWebHttpODataPageResultUtilitiesSharedModelsCorrelationGroupModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_correlation_groups_as_page_by_id_with_http_info(id, **kwargs)
        else:
            (data) = self.apps_correlation_groups_as_page_by_id_with_http_info(id, **kwargs)
            return data

    def apps_correlation_groups_as_page_by_id_with_http_info(self, id, **kwargs):
        """apps_correlation_groups_as_page_by_id

        OData V3 compliant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_correlation_groups_as_page_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str apply_policies:
        :param list[str] select_policy_ids:
        :param str locale:
        :param int top: The max number of records. (Up to 5000)
        :param int skip: The number of records to skip.
        :param str filter: A function that must evaluate to true for a record to be returned. (e.g. Name eq 'sam' or Name eq 'dan'). To filter an Id Property, open the model and see if its type is \"string\" or \"string($uuid)\". - For string no change is needed. - For \"string($uuid)\" add \"Guid\" immediately before the string (e.g. Id eq Guid'00000000-0000-0000-0000-000000000000')
        :param str select: Specifies a subset of properties to return.
        :param str orderby: Determines what values are used to order a collection of records. (e.g. Name,Id)
        :param str expand: Specifies the related resources to be included in line with retrieved resources.
        :param str inlinecount: Specifies that the response to the request MUST include the count of the number of entities in the collection of entities.
        :return: SystemWebHttpODataPageResultUtilitiesSharedModelsCorrelationGroupModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "apply_policies",
            "select_policy_ids",
            "locale",
            "top",
            "skip",
            "filter",
            "select",
            "orderby",
            "expand",
            "inlinecount",
        ]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apps_correlation_groups_as_page_by_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_correlation_groups_as_page_by_id`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]

        query_params = []
        if "apply_policies" in params:
            query_params.append(("applyPolicies", params["apply_policies"]))
        if "select_policy_ids" in params:
            query_params.append(("selectPolicyIds", params["select_policy_ids"]))
            collection_formats["selectPolicyIds"] = "multi"
        if "locale" in params:
            query_params.append(("locale", params["locale"]))
        if "top" in params:
            query_params.append(("$top", params["top"]))
        if "skip" in params:
            query_params.append(("$skip", params["skip"]))
        if "filter" in params:
            query_params.append(("$filter", params["filter"]))
        if "select" in params:
            query_params.append(("$select", params["select"]))
        if "orderby" in params:
            query_params.append(("$orderby", params["orderby"]))
        if "expand" in params:
            query_params.append(("$expand", params["expand"]))
        if "inlinecount" in params:
            query_params.append(("$inlinecount", params["inlinecount"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/v2/Apps/{id}/CorrelationGroupsAsPage",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SystemWebHttpODataPageResultUtilitiesSharedModelsCorrelationGroupModel",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_count(self, **kwargs):
        """Get applications count according to filter

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: UserSiteCommonModelsCountModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_count_with_http_info(**kwargs)
        else:
            (data) = self.apps_count_with_http_info(**kwargs)
            return data

    def apps_count_with_http_info(self, **kwargs):
        """Get applications count according to filter

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: UserSiteCommonModelsCountModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_count" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps/Count",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="UserSiteCommonModelsCountModel",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_create_app(
        self, model: CommonModelsASMModelsApplicationCreateModel, **kwargs
    ) -> CommonModelsASMModelsApplicationModel:
        """Create an application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_create_app(model, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CommonModelsASMModelsApplicationCreateModel model:  (required)
        :return: CommonModelsASMModelsApplicationModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_create_app_with_http_info(model, **kwargs)
        else:
            (data) = self.apps_create_app_with_http_info(model, **kwargs)
            return data

    def apps_create_app_with_http_info(self, model, **kwargs):
        """Create an application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_create_app_with_http_info(model, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CommonModelsASMModelsApplicationCreateModel model:  (required)
        :return: CommonModelsASMModelsApplicationModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["model"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_create_app" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'model' is set
        if self.api_client.client_side_validation and (
            "model" not in params or params["model"] is None
        ):
            raise ValueError(
                "Missing the required parameter `model` when calling `apps_create_app`"
            )

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "model" in params:
            body_params = params["model"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(
            ["application/json", "text/json", "application/x-www-form-urlencoded"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CommonModelsASMModelsApplicationModel",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_delete_app_by_id(self, id, **kwargs):
        """Delete application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_delete_app_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: application id (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_delete_app_by_id_with_http_info(id, **kwargs)
        else:
            (data) = self.apps_delete_app_by_id_with_http_info(id, **kwargs)
            return data

    def apps_delete_app_by_id_with_http_info(self, id, **kwargs):
        """Delete application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_delete_app_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: application id (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apps_delete_app_by_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_delete_app_by_id`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_delete_policy_association_by_id_and_policyid(self, id, policy_id, **kwargs):
        """Disassociate a policy from an application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_delete_policy_association_by_id_and_policyid(id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param str policy_id: Policy ID (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_delete_policy_association_by_id_and_policyid_with_http_info(
                id, policy_id, **kwargs
            )
        else:
            (data) = self.apps_delete_policy_association_by_id_and_policyid_with_http_info(
                id, policy_id, **kwargs
            )
            return data

    def apps_delete_policy_association_by_id_and_policyid_with_http_info(
        self, id, policy_id, **kwargs
    ):
        """Disassociate a policy from an application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_delete_policy_association_by_id_and_policyid_with_http_info(id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param str policy_id: Policy ID (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "policy_id"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apps_delete_policy_association_by_id_and_policyid" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_delete_policy_association_by_id_and_policyid`"
            )
        # verify the required parameter 'policy_id' is set
        if self.api_client.client_side_validation and (
            "policy_id" not in params or params["policy_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `policy_id` when calling `apps_delete_policy_association_by_id_and_policyid`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]
        if "policy_id" in params:
            path_params["policyId"] = params["policy_id"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/v2/Apps/{id}/Policy/{policyId}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_get_app_by_id(self, id, **kwargs) -> CommonModelsASMModelsApplicationModel:
        """Get an application by ID

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_get_app_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :return: CommonModelsASMModelsApplicationModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_get_app_by_id_with_http_info(id, **kwargs)
        else:
            (data) = self.apps_get_app_by_id_with_http_info(id, **kwargs)
            return data

    def apps_get_app_by_id_with_http_info(self, id, **kwargs):
        """Get an application by ID

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_get_app_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :return: CommonModelsASMModelsApplicationModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_get_app_by_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_get_app_by_id`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CommonModelsASMModelsApplicationModel",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_get_app_policies_by_id(self, id, **kwargs):
        """Get policies associated with this application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_get_app_policies_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application Id (required)
        :return: list[PolicyAssociation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_get_app_policies_by_id_with_http_info(id, **kwargs)
        else:
            (data) = self.apps_get_app_policies_by_id_with_http_info(id, **kwargs)
            return data

    def apps_get_app_policies_by_id_with_http_info(self, id, **kwargs):
        """Get policies associated with this application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_get_app_policies_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application Id (required)
        :return: list[PolicyAssociation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apps_get_app_policies_by_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_get_app_policies_by_id`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/v2/Apps/{id}/Policy",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[PolicyAssociation]",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_get_apps(self, **kwargs):
        """Get all the apps in the current context

        OData V3 compliant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_get_apps(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int top: The max number of records. (Up to 5000)
        :param int skip: The number of records to skip.
        :param str filter: A function that must evaluate to true for a record to be returned. (e.g. Name eq 'sam' or Name eq 'dan'). To filter an Id Property, open the model and see if its type is \"string\" or \"string($uuid)\". - For string no change is needed. - For \"string($uuid)\" add \"Guid\" immediately before the string (e.g. Id eq Guid'00000000-0000-0000-0000-000000000000')
        :param str select: Specifies a subset of properties to return.
        :param str orderby: Determines what values are used to order a collection of records. (e.g. Name,Id)
        :param str expand: Specifies the related resources to be included in line with retrieved resources.
        :return: list[CommonModelsASMModelsApplicationModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_get_apps_with_http_info(**kwargs)
        else:
            (data) = self.apps_get_apps_with_http_info(**kwargs)
            return data

    def apps_get_apps_with_http_info(self, **kwargs):
        """Get all the apps in the current context

        OData V3 compliant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_get_apps_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int top: The max number of records. (Up to 5000)
        :param int skip: The number of records to skip.
        :param str filter: A function that must evaluate to true for a record to be returned. (e.g. Name eq 'sam' or Name eq 'dan'). To filter an Id Property, open the model and see if its type is \"string\" or \"string($uuid)\". - For string no change is needed. - For \"string($uuid)\" add \"Guid\" immediately before the string (e.g. Id eq Guid'00000000-0000-0000-0000-000000000000')
        :param str select: Specifies a subset of properties to return.
        :param str orderby: Determines what values are used to order a collection of records. (e.g. Name,Id)
        :param str expand: Specifies the related resources to be included in line with retrieved resources.
        :return: list[CommonModelsASMModelsApplicationModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "top",
            "skip",
            "filter",
            "select",
            "orderby",
            "expand",
        ]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_get_apps" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "top" in params:
            query_params.append(("$top", params["top"]))
        if "skip" in params:
            query_params.append(("$skip", params["skip"]))
        if "filter" in params:
            query_params.append(("$filter", params["filter"]))
        if "select" in params:
            query_params.append(("$select", params["select"]))
        if "orderby" in params:
            query_params.append(("$orderby", params["orderby"]))
        if "expand" in params:
            query_params.append(("$expand", params["expand"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[CommonModelsASMModelsApplicationModel]",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_get_apps_page(self, **kwargs):
        """Get all the apps in the current context

        OData V3 compliant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_get_apps_page(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int top: The max number of records. (Up to 5000)
        :param int skip: The number of records to skip.
        :param str filter: A function that must evaluate to true for a record to be returned. (e.g. Name eq 'sam' or Name eq 'dan'). To filter an Id Property, open the model and see if its type is \"string\" or \"string($uuid)\". - For string no change is needed. - For \"string($uuid)\" add \"Guid\" immediately before the string (e.g. Id eq Guid'00000000-0000-0000-0000-000000000000')
        :param str select: Specifies a subset of properties to return.
        :param str orderby: Determines what values are used to order a collection of records. (e.g. Name,Id)
        :param str expand: Specifies the related resources to be included in line with retrieved resources.
        :param str inlinecount: Specifies that the response to the request MUST include the count of the number of entities in the collection of entities.
        :return: SystemWebHttpODataPageResultCommonModelsASMModelsApplicationModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_get_apps_page_with_http_info(**kwargs)
        else:
            (data) = self.apps_get_apps_page_with_http_info(**kwargs)
            return data

    def apps_get_apps_page_with_http_info(self, **kwargs):
        """Get all the apps in the current context

        OData V3 compliant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_get_apps_page_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int top: The max number of records. (Up to 5000)
        :param int skip: The number of records to skip.
        :param str filter: A function that must evaluate to true for a record to be returned. (e.g. Name eq 'sam' or Name eq 'dan'). To filter an Id Property, open the model and see if its type is \"string\" or \"string($uuid)\". - For string no change is needed. - For \"string($uuid)\" add \"Guid\" immediately before the string (e.g. Id eq Guid'00000000-0000-0000-0000-000000000000')
        :param str select: Specifies a subset of properties to return.
        :param str orderby: Determines what values are used to order a collection of records. (e.g. Name,Id)
        :param str expand: Specifies the related resources to be included in line with retrieved resources.
        :param str inlinecount: Specifies that the response to the request MUST include the count of the number of entities in the collection of entities.
        :return: SystemWebHttpODataPageResultCommonModelsASMModelsApplicationModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "top",
            "skip",
            "filter",
            "select",
            "orderby",
            "expand",
            "inlinecount",
        ]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_get_apps_page" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "top" in params:
            query_params.append(("$top", params["top"]))
        if "skip" in params:
            query_params.append(("$skip", params["skip"]))
        if "filter" in params:
            query_params.append(("$filter", params["filter"]))
        if "select" in params:
            query_params.append(("$select", params["select"]))
        if "orderby" in params:
            query_params.append(("$orderby", params["orderby"]))
        if "expand" in params:
            query_params.append(("$expand", params["expand"]))
        if "inlinecount" in params:
            query_params.append(("$inlinecount", params["inlinecount"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps/GetAsPage",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="SystemWebHttpODataPageResultCommonModelsASMModelsApplicationModel",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_group_count(self, grouping, **kwargs):
        """Get applications group count according to filter

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_group_count(grouping, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grouping: (required)
        :return: UserSiteCommonModelsGroupCountModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_group_count_with_http_info(grouping, **kwargs)
        else:
            (data) = self.apps_group_count_with_http_info(grouping, **kwargs)
            return data

    def apps_group_count_with_http_info(self, grouping, **kwargs):
        """Get applications group count according to filter

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_group_count_with_http_info(grouping, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grouping: (required)
        :return: UserSiteCommonModelsGroupCountModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["grouping"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_group_count" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'grouping' is set
        if self.api_client.client_side_validation and (
            "grouping" not in params or params["grouping"] is None
        ):
            raise ValueError(
                "Missing the required parameter `grouping` when calling `apps_group_count`"
            )

        collection_formats = {}

        path_params = {}

        query_params = []
        if "grouping" in params:
            query_params.append(("grouping", params["grouping"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps/GroupCount",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="UserSiteCommonModelsGroupCountModel",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_import_file(self, file_to_upload, asset_group_id, **kwargs):
        """Import Apps

        Import Apps from uploaded file to application specified with id.<br />              Includes file format validation.<br />              The expected Content-Type of the request is multipart/form-data. The request should contain a single file parameter named \"fileToUpload\".
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_import_file(file_to_upload, asset_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file_to_upload: (required)
        :param str asset_group_id: (required)
        :param str file_name: If provided, this parameter will override the name of the uploaded file, including its extension(CSV).
        :return: ImportAppResultModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_import_file_with_http_info(file_to_upload, asset_group_id, **kwargs)
        else:
            (data) = self.apps_import_file_with_http_info(file_to_upload, asset_group_id, **kwargs)
            return data

    def apps_import_file_with_http_info(self, file_to_upload, asset_group_id, **kwargs):
        """Import Apps

        Import Apps from uploaded file to application specified with id.<br />              Includes file format validation.<br />              The expected Content-Type of the request is multipart/form-data. The request should contain a single file parameter named \"fileToUpload\".
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_import_file_with_http_info(file_to_upload, asset_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file_to_upload: (required)
        :param str asset_group_id: (required)
        :param str file_name: If provided, this parameter will override the name of the uploaded file, including its extension(CSV).
        :return: ImportAppResultModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["file_to_upload", "asset_group_id", "file_name"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_import_file" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'file_to_upload' is set
        if self.api_client.client_side_validation and (
            "file_to_upload" not in params or params["file_to_upload"] is None
        ):
            raise ValueError(
                "Missing the required parameter `file_to_upload` when calling `apps_import_file`"
            )
        # verify the required parameter 'asset_group_id' is set
        if self.api_client.client_side_validation and (
            "asset_group_id" not in params or params["asset_group_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `asset_group_id` when calling `apps_import_file`"
            )

        if self.api_client.client_side_validation and (
            "file_name" in params and len(params["file_name"]) > 2048
        ):
            raise ValueError(
                "Invalid value for parameter `file_name` when calling `apps_import_file`, length must be less than or equal to `2048`"
            )
        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "file_to_upload" in params:
            local_var_files["fileToUpload"] = params["file_to_upload"]
        if "file_name" in params:
            form_params.append(("fileName", params["file_name"]))
        if "asset_group_id" in params:
            form_params.append(("assetGroupId", params["asset_group_id"]))

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(
            ["multipart/form-data"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps/ImportFile",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ImportAppResultModel",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_license_by_id(self, id, **kwargs):
        """Get application license

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_license_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param str technology: Requested technology
        :return: CommonModelsASMModelsAppLicense
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_license_by_id_with_http_info(id, **kwargs)
        else:
            (data) = self.apps_license_by_id_with_http_info(id, **kwargs)
            return data

    def apps_license_by_id_with_http_info(self, id, **kwargs):
        """Get application license

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_license_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param str technology: Requested technology
        :return: CommonModelsASMModelsAppLicense
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "technology"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_license_by_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_license_by_id`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]

        query_params = []
        if "technology" in params:
            query_params.append(("technology", params["technology"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/v2/Apps/{id}/License",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CommonModelsASMModelsAppLicense",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_reset_by_id(self, id, reset_options, **kwargs):
        """Reset application

        Reset options (set in the request body):<br /><b>DeleteIssues:</b>  Delete all the Application’s issues.<br /><b>DeleteScans:</b>  Delete all the Application’s scans.<br /><b>DeleteChartsData:</b> Delete all the data related to the application from the Dashboard charts. (This will affect charts from previous dates too. The application will be removed from all graphs that contain application counts.)<br />
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_reset_by_id(id, reset_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application id (required)
        :param ApplicationResetModel reset_options: Determine which data will be cleared (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_reset_by_id_with_http_info(id, reset_options, **kwargs)
        else:
            (data) = self.apps_reset_by_id_with_http_info(id, reset_options, **kwargs)
            return data

    def apps_reset_by_id_with_http_info(self, id, reset_options, **kwargs):
        """Reset application

        Reset options (set in the request body):<br /><b>DeleteIssues:</b>  Delete all the Application’s issues.<br /><b>DeleteScans:</b>  Delete all the Application’s scans.<br /><b>DeleteChartsData:</b> Delete all the data related to the application from the Dashboard charts. (This will affect charts from previous dates too. The application will be removed from all graphs that contain application counts.)<br />
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_reset_by_id_with_http_info(id, reset_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application id (required)
        :param ApplicationResetModel reset_options: Determine which data will be cleared (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "reset_options"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_reset_by_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError("Missing the required parameter `id` when calling `apps_reset_by_id`")
        # verify the required parameter 'reset_options' is set
        if self.api_client.client_side_validation and (
            "reset_options" not in params or params["reset_options"] is None
        ):
            raise ValueError(
                "Missing the required parameter `reset_options` when calling `apps_reset_by_id`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "reset_options" in params:
            body_params = params["reset_options"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(
            ["application/json", "text/json", "application/x-www-form-urlencoded"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/v2/Apps/{id}/Reset",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="object",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_scans_by_id(self, id, **kwargs):
        """Get scans under the given application

        This API is obsolete. Please refer to API: GET /api/v2/Scans/GetAsPageMin</br>OData V3 compliant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_scans_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param int top: The max number of records. (Up to 5000)
        :param int skip: The number of records to skip.
        :param str filter: A function that must evaluate to true for a record to be returned. (e.g. Name eq 'sam' or Name eq 'dan'). To filter an Id Property, open the model and see if its type is \"string\" or \"string($uuid)\". - For string no change is needed. - For \"string($uuid)\" add \"Guid\" immediately before the string (e.g. Id eq Guid'00000000-0000-0000-0000-000000000000')
        :param str select: Specifies a subset of properties to return.
        :param str orderby: Determines what values are used to order a collection of records. (e.g. Name,Id)
        :param str expand: Specifies the related resources to be included in line with retrieved resources.
        :return: list[AppScanSaaSModelsV2Scan1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_scans_by_id_with_http_info(id, **kwargs)
        else:
            (data) = self.apps_scans_by_id_with_http_info(id, **kwargs)
            return data

    def apps_scans_by_id_with_http_info(self, id, **kwargs):
        """Get scans under the given application

        This API is obsolete. Please refer to API: GET /api/v2/Scans/GetAsPageMin</br>OData V3 compliant
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_scans_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param int top: The max number of records. (Up to 5000)
        :param int skip: The number of records to skip.
        :param str filter: A function that must evaluate to true for a record to be returned. (e.g. Name eq 'sam' or Name eq 'dan'). To filter an Id Property, open the model and see if its type is \"string\" or \"string($uuid)\". - For string no change is needed. - For \"string($uuid)\" add \"Guid\" immediately before the string (e.g. Id eq Guid'00000000-0000-0000-0000-000000000000')
        :param str select: Specifies a subset of properties to return.
        :param str orderby: Determines what values are used to order a collection of records. (e.g. Name,Id)
        :param str expand: Specifies the related resources to be included in line with retrieved resources.
        :return: list[AppScanSaaSModelsV2Scan1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "top",
            "skip",
            "filter",
            "select",
            "orderby",
            "expand",
        ]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'" " to method apps_scans_by_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError("Missing the required parameter `id` when calling `apps_scans_by_id`")

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]

        query_params = []
        if "top" in params:
            query_params.append(("$top", params["top"]))
        if "skip" in params:
            query_params.append(("$skip", params["skip"]))
        if "filter" in params:
            query_params.append(("$filter", params["filter"]))
        if "select" in params:
            query_params.append(("$select", params["select"]))
        if "orderby" in params:
            query_params.append(("$orderby", params["orderby"]))
        if "expand" in params:
            query_params.append(("$expand", params["expand"]))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/v2/Apps/{id}/Scans",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[AppScanSaaSModelsV2Scan1]",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_update_app_by_id(self, id, model, **kwargs):
        """Update application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_update_app_by_id(id, model, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application Id (required)
        :param CommonModelsASMModelsApplicationUpdateModel model:  (required)
        :return: CommonModelsASMModelsApplicationModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_update_app_by_id_with_http_info(id, model, **kwargs)
        else:
            (data) = self.apps_update_app_by_id_with_http_info(id, model, **kwargs)
            return data

    def apps_update_app_by_id_with_http_info(self, id, model, **kwargs):
        """Update application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_update_app_by_id_with_http_info(id, model, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application Id (required)
        :param CommonModelsASMModelsApplicationUpdateModel model:  (required)
        :return: CommonModelsASMModelsApplicationModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "model"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apps_update_app_by_id" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_update_app_by_id`"
            )
        # verify the required parameter 'model' is set
        if self.api_client.client_side_validation and (
            "model" not in params or params["model"] is None
        ):
            raise ValueError(
                "Missing the required parameter `model` when calling `apps_update_app_by_id`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "model" in params:
            body_params = params["model"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(
            ["application/json", "text/json", "application/x-www-form-urlencoded"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/V2/Apps/{id}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CommonModelsASMModelsApplicationModel",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def apps_update_policy_by_id_and_policyid(self, id, policy_id, configuration_model, **kwargs):
        """Update the policy parameters for this application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_update_policy_by_id_and_policyid(id, policy_id, configuration_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param str policy_id: Policy ID (required)
        :param PolicyConfiguration configuration_model: Policy configuration for this application (required)
        :return: PolicyAssociation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.apps_update_policy_by_id_and_policyid_with_http_info(
                id, policy_id, configuration_model, **kwargs
            )
        else:
            (data) = self.apps_update_policy_by_id_and_policyid_with_http_info(
                id, policy_id, configuration_model, **kwargs
            )
            return data

    def apps_update_policy_by_id_and_policyid_with_http_info(
        self, id, policy_id, configuration_model, **kwargs
    ):
        """Update the policy parameters for this application

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apps_update_policy_by_id_and_policyid_with_http_info(id, policy_id, configuration_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application ID (required)
        :param str policy_id: Policy ID (required)
        :param PolicyConfiguration configuration_model: Policy configuration for this application (required)
        :return: PolicyAssociation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "policy_id", "configuration_model"]
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apps_update_policy_by_id_and_policyid" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ("id" not in params or params["id"] is None):
            raise ValueError(
                "Missing the required parameter `id` when calling `apps_update_policy_by_id_and_policyid`"
            )
        # verify the required parameter 'policy_id' is set
        if self.api_client.client_side_validation and (
            "policy_id" not in params or params["policy_id"] is None
        ):
            raise ValueError(
                "Missing the required parameter `policy_id` when calling `apps_update_policy_by_id_and_policyid`"
            )
        # verify the required parameter 'configuration_model' is set
        if self.api_client.client_side_validation and (
            "configuration_model" not in params or params["configuration_model"] is None
        ):
            raise ValueError(
                "Missing the required parameter `configuration_model` when calling `apps_update_policy_by_id_and_policyid`"
            )

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]
        if "policy_id" in params:
            path_params["policyId"] = params["policy_id"]

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "configuration_model" in params:
            body_params = params["configuration_model"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "text/json", "text/csv"]
        )

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(
            ["application/json", "text/json", "application/x-www-form-urlencoded"]
        )

        # Authentication setting
        auth_settings = ["AccessToken"]

        return self.api_client.call_api(
            "/api/v2/Apps/{id}/Policy/{policyId}",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PolicyAssociation",
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
