"""Models for devvit-manager."""
from __future__ import annotations

import base64
import json
from dataclasses import dataclass, field
from functools import cached_property
from typing import TypedDict

import praw
import prawcore

from .const import (
    DEVVIT_CLIENT_ID,
    DEVVIT_COPY_PASTE_CLIENT_ID,
    TOKEN_PATH,
    __version__,
)


class DevvitTokenFile(TypedDict):
    """Represents the token file generated by devvit."""

    token: str
    copyPaste: str


class DevvitToken(TypedDict):
    """Represents the token payload."""

    refreshToken: str
    accessToken: str
    expiresAt: int
    scope: str
    tokenType: str


@dataclass
class Profile:
    """A profile for a user."""

    token_data: DevvitTokenFile = field(repr=False)

    @cached_property
    def client_id(self):
        """Obtain the client ID from token data."""
        if self.token_data["copyPaste"]:
            return DEVVIT_COPY_PASTE_CLIENT_ID
        else:
            return DEVVIT_CLIENT_ID

    @cached_property
    def refresh_token(self) -> str:
        """Obtain the refresh token from token data."""
        return self.token_payload["refreshToken"]

    @cached_property
    def token_payload(self) -> DevvitToken:
        """Obtain the token payload from token data."""
        return json.loads(
            base64.b64decode((self.token_data["token"].encode("utf-8")).decode("utf-8"))
        )

    @cached_property
    def username(self) -> str | None:
        """Fetch the username associated with the refresh token."""
        reddit = praw.Reddit(
            client_id=self.client_id,
            client_secret="",
            refresh_token=self.refresh_token,
            user_agent=f"devvit-manager v{__version__}",
        )
        try:
            return reddit.user.me().name
        except prawcore.exceptions.OAuthException:
            return None

    @cached_property
    def is_valid(self) -> bool:
        """Check if the profile is valid."""
        return self.username is not None

    @property
    def active(self):
        """Check if the profile is active."""
        if not TOKEN_PATH.exists():
            return False
        with TOKEN_PATH.open() as f:
            return self.token_data == json.load(f)

    @classmethod
    def dump(cls, profiles: dict[str, Profile]) -> tuple[str | None, DevvitTokenFile]:
        """Dump the profiles to a dict."""
        for profile in profiles.values():
            if profile.is_valid:
                yield profile.username, profile.token_data

    @classmethod
    def from_dict(cls, data: dict[str, dict[str, str]]) -> dict[str, Profile]:
        """Create a list of profiles from a dict."""
        return {k: cls(v) for k, v in data.items()}
