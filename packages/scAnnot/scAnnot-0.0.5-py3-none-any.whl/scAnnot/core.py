# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['model_paths', 'scAnnot']

# %% ../nbs/00_core.ipynb 4
import numpy as np
import scanpy as sc
import scvi
from fastcore.script import *
from scipy import sparse
import warnings

# %% ../nbs/00_core.ipynb 13
@call_parse
def scAnnot(h5:str, #the input h5ad file, must have row counts in X or layers
            output:str = None, # The path of output file. 1. None->output AnnData object with predicted labels, 2. a path end with h5ad->write out the AnnData. 3. a path end with csv-> write out the table of predicted labels. 
            model:str='Adult', # Adult and Fetal models are included. select Adult or Fetal.
            show:bool=False, #show umap plot. may not work in command line
            latent:bool=False, #add scvi latent space to anndata
           ):
    if model in ['Adult','Fetal']:
        sup_model_path,sub_model_path,ref_path=model_paths[model]
    else:
        raise(f'This {model} has not been deployed yet')
    warnings.filterwarnings("ignore")
    ad=sc.read(h5)
   
    if 'counts' not in ad.layers.keys():
        ad.layers['counts']=ad.X
    arr=ad.layers['counts'].data
    if not np.array_equal(arr, np.round(arr)):
        raise ValueError("Not all counts are integers")
    #make X to csr sparse matrix
    ad.layers['counts']=sparse.csr_matrix(ad.layers['counts'])
    #concatenate query and ref
    ref=sc.read(ref_path)
    ref_var_idx=ref.var.index
    ad=ad[:,ad.var.index.isin(ref_var_idx)]
    print(f'{ad.shape[1]} of genes are found in ref genes (total {ref.shape[1]}). The percentage is {ad.shape[1]/ref.shape[1]}')
    ad=ad.concatenate(ref,join='outer')[:-1] #remove ref cell
    ad=ad[:,ref.var.index] #reorder var by ref var
    ad.var['inref']=ad.var.index.isin(ref_var_idx)
    if not ad.var.index.equals(ref.var.index):
        raise ValueError("The order of gene are not the same between query and reference")
    model=scvi.model.SCANVI.load_query_data(
            ad,
            sup_model_path,
            freeze_dropout = True,
            inplace_subset_query_vars = True,
        )
    
    ad.obs['predict_level1']=model.predict()
    
    if show:
        model.is_trained=True
        latent=sc.AnnData(model.get_latent_representation())
          
    ad.obs['predict_level2']='unknown'
    for i in ad.obs['predict_level1'].unique():
        sub_ad=ad[ad.obs.predict_level1==i]
        model=scvi.model.SCANVI.load_query_data(
            sub_ad,
            sub_model_path+f'_{i}/',
            freeze_dropout = True,
            inplace_subset_query_vars = True,
        )
        ad.obs['predict_level2'][ad.obs.predict_level1==i]=model.predict()
    if show:
        latent.obs['predict_level1']=ad.obs['predict_level1'].tolist()
        latent.obs['predict_level2']=ad.obs['predict_level2'].tolist()
        sc.pp.neighbors(latent)
        sc.tl.umap(latent)
        sc.pl.umap(latent,color=['predict_level1', 'predict_level2'],frameon=False,ncols=1)
       
    if latent:
        ad.obsm['X_scvi']=latent.X
    if output is not None:
        if output.endswith('.csv'):
            ad.obs[['predict_level1','predict_level2']].to_csv(output)
            return
        if output.split('.')[-1] in ['h5ad','h5']:
            ad.write_h5ad(output)
            return
    return ad

model_paths={
'Adult':['/home/huang_yin/projA/scBERT/model/twostep_2layer_subgenes/scanvi_3_epoch_model/',
         '/home/huang_yin/projA/scBERT/model/twostep_2layer_subgenes/v1_scanvi_subtype',
         '/home/huang_yin/projA/scBERT/model/reference_genes.h5ad',
        ],
'Fetal':['/home/huang_yin/projA/scBERT/model/twostep_2layer_subgenes/fetal_scanvi_2_epoch_model/',
         '/home/huang_yin/projA/scBERT/model/twostep_2layer_subgenes/fetal_scanvi_subtype',
         '/home/huang_yin/projA/scBERT/model/fetal_reference_genes.h5ad',
        ]
}
